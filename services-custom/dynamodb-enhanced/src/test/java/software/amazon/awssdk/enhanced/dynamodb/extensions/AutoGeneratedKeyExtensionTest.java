/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 */

package software.amazon.awssdk.enhanced.dynamodb.extensions;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;
import static software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedUuidExtension.AttributeTags.autoGeneratedUuidAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondarySortKey;

import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.junit.jupiter.api.Test;
import software.amazon.awssdk.enhanced.dynamodb.OperationContext;
import software.amazon.awssdk.enhanced.dynamodb.TableMetadata;
import software.amazon.awssdk.enhanced.dynamodb.internal.extensions.DefaultDynamoDbExtensionContext;
import software.amazon.awssdk.enhanced.dynamodb.internal.operations.DefaultOperationContext;
import software.amazon.awssdk.enhanced.dynamodb.internal.operations.OperationName;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;

public class AutoGeneratedKeyExtensionTest {

    private static final String RECORD_ID = "1";
    private static final String TABLE_NAME = "table-name";

    private static final OperationContext PRIMARY_CONTEXT =
        DefaultOperationContext.create(TABLE_NAME, TableMetadata.primaryIndexName());

    private final AutoGeneratedKeyExtension extension = AutoGeneratedKeyExtension.create();

    /**
     * Schema that places @DynamoDbAutoGeneratedKey on GSI key ("keyAttribute") -> the validation passes.
     */
    private static final StaticTableSchema<AutogeneratedKeyItem> ITEM_WITH_KEY_SCHEMA =
        StaticTableSchema.builder(AutogeneratedKeyItem.class)
                         .newItemSupplier(AutogeneratedKeyItem::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(AutogeneratedKeyItem::getId)
                                                           .setter(AutogeneratedKeyItem::setId)
                                                           .addTag(primaryPartitionKey())
                                                           .addTag(autoGeneratedKeyAttribute()))
                         .addAttribute(String.class, a -> a.name("keyAttribute")
                                                           .getter(AutogeneratedKeyItem::getKeyAttribute)
                                                           .setter(AutogeneratedKeyItem::setKeyAttribute)
                                                           .tags(
                                                               secondaryPartitionKey("gsi_keys_only"),
                                                               autoGeneratedKeyAttribute()))
                         .addAttribute(String.class, a -> a.name("simpleString")
                                                           .getter(AutogeneratedKeyItem::getSimpleString)
                                                           .setter(AutogeneratedKeyItem::setSimpleString))
                         .build();

    /**
     * Schema that places @DynamoDbAutoGeneratedKey on a NON-KEY attribute -> triggers the exception.
     */
    private static final StaticTableSchema<AutogeneratedKeyItem> INVALID_NONKEY_AUTOGEN_SCHEMA =
        StaticTableSchema.builder(AutogeneratedKeyItem.class)
                         .newItemSupplier(AutogeneratedKeyItem::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(AutogeneratedKeyItem::getId)
                                                           .setter(AutogeneratedKeyItem::setId)
                                                           .addTag(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("keyAttribute")
                                                           .getter(AutogeneratedKeyItem::getKeyAttribute)
                                                           .setter(AutogeneratedKeyItem::setKeyAttribute)
                                                           // index tags not defined â€” autogen on non-key fails at beforeWrite()
                                                           .addTag(autoGeneratedKeyAttribute()))
                         .addAttribute(String.class, a -> a.name("simpleString")
                                                           .getter(AutogeneratedKeyItem::getSimpleString)
                                                           .setter(AutogeneratedKeyItem::setSimpleString))
                         .build();

    /**
     * Schema that places @DynamoDbAutoGeneratedKey on LSI key ("simpleString") -> the validation passes.
     */
    private static final StaticTableSchema<AutogeneratedKeyItem> LSI_SK_AUTOGEN_SCHEMA =
        StaticTableSchema.builder(AutogeneratedKeyItem.class)
                         .newItemSupplier(AutogeneratedKeyItem::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(AutogeneratedKeyItem::getId)
                                                           .setter(AutogeneratedKeyItem::setId)
                                                           .addTag(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("keyAttribute")
                                                           .getter(AutogeneratedKeyItem::getKeyAttribute)
                                                           .setter(AutogeneratedKeyItem::setKeyAttribute))
                         .addAttribute(String.class, a -> a.name("simpleString")
                                                           .getter(AutogeneratedKeyItem::getSimpleString)
                                                           .setter(AutogeneratedKeyItem::setSimpleString)
                                                           .tags(
                                                               secondarySortKey("lsi1"),
                                                               autoGeneratedKeyAttribute()))
                         .build();

    @Test
    public void updateItem_withExistingKey_preservesValueAndDoesNotGenerateNewOne() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);
        String preset = UUID.randomUUID().toString();
        item.setKeyAttribute(preset);

        Map<String, AttributeValue> items = ITEM_WITH_KEY_SCHEMA.itemToMap(item, true);
        assertThat(items).hasSize(2);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(ITEM_WITH_KEY_SCHEMA.tableMetadata())
                                           .operationName(OperationName.UPDATE_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        Map<String, AttributeValue> transformed = result.transformedItem();
        assertThat(transformed).isNotNull().hasSize(2);
        assertThat(transformed).containsEntry("id", AttributeValue.fromS(RECORD_ID));

        assertThat(isValidUuid(transformed.get("keyAttribute").s())).isTrue();
        assertThat(result.updateExpression()).isNull();
    }

    @Test
    public void updateItem_withoutExistingKey_generatesNewUuid() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = ITEM_WITH_KEY_SCHEMA.itemToMap(item, true);
        assertThat(items).hasSize(1);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(ITEM_WITH_KEY_SCHEMA.tableMetadata())
                                           .operationName(OperationName.UPDATE_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        Map<String, AttributeValue> transformed = result.transformedItem();
        assertThat(transformed).isNotNull().hasSize(2);
        assertThat(transformed).containsEntry("id", AttributeValue.fromS(RECORD_ID));
        assertThat(isValidUuid(transformed.get("keyAttribute").s())).isTrue();
        assertThat(result.updateExpression()).isNull();
    }

    @Test
    public void updateItem_withMissingKeyAttribute_insertsGeneratedUuid() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = ITEM_WITH_KEY_SCHEMA.itemToMap(item, true);
        assertThat(items).hasSize(1);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(ITEM_WITH_KEY_SCHEMA.tableMetadata())
                                           .operationName(OperationName.UPDATE_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        assertThat(result.transformedItem()).isNotNull();
        assertThat(result.updateExpression()).isNull();
        assertThat(result.transformedItem()).hasSize(2);
        assertThat(isValidUuid(result.transformedItem().get("keyAttribute").s())).isTrue();
    }

    @Test
    public void nonStringAttributeAnnotatedWithAutoGeneratedKey_throwsIllegalArgumentException() {
        assertThatExceptionOfType(IllegalArgumentException.class)
            .isThrownBy(() ->
                            StaticTableSchema.builder(AutogeneratedKeyItem.class)
                                             .newItemSupplier(AutogeneratedKeyItem::new)
                                             .addAttribute(String.class, a -> a.name("id")
                                                                               .getter(AutogeneratedKeyItem::getId)
                                                                               .setter(AutogeneratedKeyItem::setId)
                                                                               .addTag(primaryPartitionKey()))
                                             .addAttribute(Integer.class, a -> a.name("intAttribute")
                                                                                .getter(AutogeneratedKeyItem::getIntAttribute)
                                                                                .setter(AutogeneratedKeyItem::setIntAttribute)
                                                                                .addTag(autoGeneratedKeyAttribute()))
                                             .addAttribute(String.class, a -> a.name("simpleString")
                                                                               .getter(AutogeneratedKeyItem::getSimpleString)
                                                                               .setter(AutogeneratedKeyItem::setSimpleString))
                                             .build()
            )
            .withMessage(
                "Attribute 'intAttribute' of Class type class java.lang.Integer is not a suitable Java Class type "
                + "to be used as a Auto Generated Key attribute. Only String Class type is supported.");
    }

    @Test
    public void autoGeneratedKey_onSecondaryPartitionKey_generatesUuid() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = ITEM_WITH_KEY_SCHEMA.itemToMap(item, true);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(ITEM_WITH_KEY_SCHEMA.tableMetadata())
                                           .operationName(OperationName.PUT_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        Map<String, AttributeValue> transformed = result.transformedItem();
        assertThat(transformed).isNotNull();
        assertThat(isValidUuid(transformed.get("keyAttribute").s())).isTrue();
    }

    @Test
    public void autoGeneratedKey_onSecondarySortKey_generatesUuid() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = LSI_SK_AUTOGEN_SCHEMA.itemToMap(item, true);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(LSI_SK_AUTOGEN_SCHEMA.tableMetadata())
                                           .operationName(OperationName.PUT_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        Map<String, AttributeValue> transformed = result.transformedItem();
        assertThat(transformed).isNotNull();
        assertThat(isValidUuid(transformed.get("simpleString").s())).isTrue();
    }

    @Test
    public void autoGeneratedKey_onNonKeyAttribute_throwsIllegalArgumentException() {
        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = INVALID_NONKEY_AUTOGEN_SCHEMA.itemToMap(item, true);

        assertThatExceptionOfType(IllegalArgumentException.class)
            .isThrownBy(() -> extension.beforeWrite(
                DefaultDynamoDbExtensionContext.builder()
                                               .items(items)
                                               .tableMetadata(INVALID_NONKEY_AUTOGEN_SCHEMA.tableMetadata())
                                               .operationName(OperationName.PUT_ITEM)
                                               .operationContext(PRIMARY_CONTEXT)
                                               .build())
            )
            .withMessage("@DynamoDbAutoGeneratedKey can only be applied to key attributes: "
                         + "primary partition key, primary sort key, or GSI/LSI partition/sort keys. "
                         + "Invalid placement on attribute: keyAttribute");
    }

    @Test
    public void conflictingAnnotations_onSameAttribute_throwsIllegalArgumentException() {
        // Create a schema with both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid on the same attribute
        StaticTableSchema<AutogeneratedKeyItem> conflictingSchema =
            StaticTableSchema
                .builder(AutogeneratedKeyItem.class)
                .newItemSupplier(AutogeneratedKeyItem::new)
                .addAttribute(String.class, a -> a.name("id")
                                                  .getter(AutogeneratedKeyItem::getId)
                                                  .setter(AutogeneratedKeyItem::setId)
                                                  .addTag(primaryPartitionKey())
                                                  // Both annotations on the same attribute
                                                  .addTag(autoGeneratedKeyAttribute())
                                                  .addTag(autoGeneratedUuidAttribute()))
                .addAttribute(String.class, a -> a.name("simpleString")
                                                  .getter(AutogeneratedKeyItem::getSimpleString)
                                                  .setter(AutogeneratedKeyItem::setSimpleString))
                .build();

        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = conflictingSchema.itemToMap(item, true);

        assertThatExceptionOfType(IllegalArgumentException.class)
            .isThrownBy(() -> extension.beforeWrite(
                DefaultDynamoDbExtensionContext.builder()
                                               .items(items)
                                               .tableMetadata(conflictingSchema.tableMetadata())
                                               .operationName(OperationName.PUT_ITEM)
                                               .operationContext(PRIMARY_CONTEXT)
                                               .build())
            )
            .withMessage(
                "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
    }

    @Test
    public void conflictingAnnotations_onSecondaryKey_throwsIllegalArgumentException() {
        // Create a schema with both annotations on a GSI key
        StaticTableSchema<AutogeneratedKeyItem> conflictingGsiSchema =
            StaticTableSchema
                .builder(AutogeneratedKeyItem.class)
                .newItemSupplier(AutogeneratedKeyItem::new)
                .addAttribute(String.class, a -> a.name("id")
                                                  .getter(AutogeneratedKeyItem::getId)
                                                  .setter(AutogeneratedKeyItem::setId)
                                                  .addTag(primaryPartitionKey()))
                .addAttribute(String.class, a -> a.name("keyAttribute")
                                                  .getter(AutogeneratedKeyItem::getKeyAttribute)
                                                  .setter(AutogeneratedKeyItem::setKeyAttribute)
                                                  .addTag(secondaryPartitionKey("gsi1"))
                                                  // Both annotations on the same GSI key
                                                  .addTag(autoGeneratedKeyAttribute())
                                                  .addTag(autoGeneratedUuidAttribute()))
                .addAttribute(String.class, a -> a.name("simpleString")
                                                  .getter(AutogeneratedKeyItem::getSimpleString)
                                                  .setter(AutogeneratedKeyItem::setSimpleString))
                .build();

        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = conflictingGsiSchema.itemToMap(item, true);

        assertThatExceptionOfType(IllegalArgumentException.class)
            .isThrownBy(() -> extension.beforeWrite(
                DefaultDynamoDbExtensionContext.builder()
                                               .items(items)
                                               .tableMetadata(conflictingGsiSchema.tableMetadata())
                                               .operationName(OperationName.PUT_ITEM)
                                               .operationContext(PRIMARY_CONTEXT)
                                               .build()))
            .withMessage(
                "Attribute 'keyAttribute' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
    }

    @Test
    public void conflictDetection_worksRegardlessOfExtensionOrder() {
        StaticTableSchema<AutogeneratedKeyItem> conflictingSchema =
            StaticTableSchema
                .builder(AutogeneratedKeyItem.class)
                .newItemSupplier(AutogeneratedKeyItem::new)
                .addAttribute(String.class, a -> a.name("id")
                                                  .getter(AutogeneratedKeyItem::getId)
                                                  .setter(AutogeneratedKeyItem::setId)
                                                  .addTag(primaryPartitionKey())
                                                  .addTag(autoGeneratedKeyAttribute())
                                                  .addTag(autoGeneratedUuidAttribute()))
                .build();

        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);

        Map<String, AttributeValue> items = conflictingSchema.itemToMap(item, true);

        // Test that the conflict is detected regardless of which extension runs first
        assertThatExceptionOfType(IllegalArgumentException.class)
            .isThrownBy(() -> extension.beforeWrite(
                DefaultDynamoDbExtensionContext.builder()
                                               .items(items)
                                               .tableMetadata(conflictingSchema.tableMetadata())
                                               .operationName(OperationName.PUT_ITEM)
                                               .operationContext(PRIMARY_CONTEXT)
                                               .build()))
            .withMessage(
                "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
    }

    @Test
    public void beforeWrite_noAttributesTaggedWithAutogeneratedKey_returnsEmptyModification() {
        StaticTableSchema<AutogeneratedKeyItem> schemaWithoutTags =
            StaticTableSchema.builder(AutogeneratedKeyItem.class)
                             .newItemSupplier(AutogeneratedKeyItem::new)
                             .addAttribute(String.class, a -> a.name("id")
                                                               .getter(AutogeneratedKeyItem::getId)
                                                               .setter(AutogeneratedKeyItem::setId)
                                                               .addTag(primaryPartitionKey()))
                             .build();

        AutogeneratedKeyItem item = new AutogeneratedKeyItem();
        item.setId(RECORD_ID);
        Map<String, AttributeValue> items = schemaWithoutTags.itemToMap(item, true);

        WriteModification result = extension.beforeWrite(
            DefaultDynamoDbExtensionContext.builder()
                                           .items(items)
                                           .tableMetadata(schemaWithoutTags.tableMetadata())
                                           .operationName(OperationName.PUT_ITEM)
                                           .operationContext(PRIMARY_CONTEXT)
                                           .build());

        assertThat(result).isEqualTo(WriteModification.builder().build());
    }

    private static class AutogeneratedKeyItem {

        private String id;
        private String keyAttribute;
        private String simpleString;
        private Integer intAttribute;

        AutogeneratedKeyItem() {
        }

        public Integer getIntAttribute() {
            return intAttribute;
        }

        public void setIntAttribute(Integer intAttribute) {
            this.intAttribute = intAttribute;
        }

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getKeyAttribute() {
            return keyAttribute;
        }

        public void setKeyAttribute(String keyAttribute) {
            this.keyAttribute = keyAttribute;
        }

        public String getSimpleString() {
            return simpleString;
        }

        public void setSimpleString(String simpleString) {
            this.simpleString = simpleString;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof AutogeneratedKeyItem)) {
                return false;
            }
            AutogeneratedKeyItem that = (AutogeneratedKeyItem) o;
            return Objects.equals(id, that.id)
                   && Objects.equals(keyAttribute, that.keyAttribute)
                   && Objects.equals(simpleString, that.simpleString);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, keyAttribute, simpleString);
        }
    }
}
