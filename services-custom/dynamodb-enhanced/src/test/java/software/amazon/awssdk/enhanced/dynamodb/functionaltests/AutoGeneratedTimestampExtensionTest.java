/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension.AttributeTags.autoGeneratedTimestampAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.buildStaticImmutableSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.buildStaticImmutableSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.buildStaticSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.buildStaticSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.internal.AttributeValues.stringValue;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.updateBehavior;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.converters.EpochMillisFormatTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.converters.TimeFormatUpdateTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.NestedBeanChild;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.NestedBeanWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.NestedImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.NestedStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleBeanWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleBeanWithMap;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleBeanWithSet;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleImmutableRecordWithMap;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleImmutableRecordWithSet;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampTestModels.SimpleStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithInvalidAttributeNameOnNestedLevel;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithInvalidAttributeNameOnRoot;
import software.amazon.awssdk.enhanced.dynamodb.mapper.BeanTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.PutItemEnhancedRequest;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;
import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;

public class AutoGeneratedTimestampExtensionTest extends LocalDynamoDbSyncTestBase {

    private static final Instant MOCKED_INSTANT_NOW = Instant.now(Clock.fixed(Instant.parse("2019-01-13T14:00:00Z"),
                                                                              ZoneOffset.UTC));

    private static final Instant MOCKED_INSTANT_UPDATE_ONE = Instant.now(Clock.fixed(Instant.parse("2019-01-14T14:00:00Z"),
                                                                                     ZoneOffset.UTC));

    private static final Instant MOCKED_INSTANT_UPDATE_TWO = Instant.now(Clock.fixed(Instant.parse("2019-01-15T14:00:00Z"),
                                                                                     ZoneOffset.UTC));

    private final Clock mockClock = Mockito.mock(Clock.class);
    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(AutoGeneratedTimestampRecordExtension.builder().baseClock(mockClock).build())
                              .build();

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Before
    public void setup() {
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_NOW);
    }

    @After
    public void cleanup() {
        // Tables are cleaned up by individual tests
    }

    @Test
    public void putNewRecord_setsInitialTimestamps() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        BasicRecord item = new BasicRecord()
            .setId("id")
            .setAttribute("one");

        table.putItem(r -> r.item(item));
        BasicRecord result = table.getItem(r -> r.key(k -> k.partitionValue("id")));

        BasicRecord expected = new BasicRecord()
            .setId("id")
            .setAttribute("one")
            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setCreatedDate(MOCKED_INSTANT_NOW)
            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setFlattenedRecord(new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW));

        assertThat(result, is(expected));

        // Verify converted format is stored correctly
        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        assertThat(stored.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        table.deleteTable();
    }

    @Test
    public void updateNewRecord_setsAutoFormattedTimestamps() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        BasicRecord result = table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        BasicRecord expected = new BasicRecord()
            .setId("id")
            .setAttribute("one")
            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setCreatedDate(MOCKED_INSTANT_NOW)
            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setFlattenedRecord(new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW));

        assertThat(result, is(expected));

        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        assertThat(stored.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        table.deleteTable();
    }

    @Test
    public void putExistingRecord_updatesTimestamps() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        // Initial put
        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));
        BasicRecord initial = table.getItem(r -> r.key(k -> k.partitionValue("id")));
        assertThat(initial.getCreatedDate(), is(MOCKED_INSTANT_NOW));
        assertThat(initial.getLastUpdatedDate(), is(MOCKED_INSTANT_NOW));

        // Update with new timestamp
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        BasicRecord updated = table.getItem(r -> r.key(k -> k.partitionValue("id")));
        // Note: PutItem updates both created and last updated dates
        assertThat(updated.getCreatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));
        assertThat(updated.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));

        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        assertThat(stored.item().get("convertedLastUpdatedDate").s(), is("14 01 2019 14:00:00"));

        table.deleteTable();
    }

    @Test
    public void updateExistingRecord_preservesCreatedDate() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        // Initial put
        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        // Update with new timestamp
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        BasicRecord result = table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        // UpdateItem preserves created date but updates last updated date
        assertThat(result.getCreatedDate(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));

        table.deleteTable();
    }

    @Test
    public void multipleUpdates_updatesTimestampsCorrectly() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        // Initial put
        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        // First update
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        BasicRecord firstUpdate = table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));
        assertThat(firstUpdate.getCreatedDate(), is(MOCKED_INSTANT_NOW));
        assertThat(firstUpdate.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));

        // Second update
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        BasicRecord secondUpdate = table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));
        assertThat(secondUpdate.getCreatedDate(), is(MOCKED_INSTANT_NOW));
        assertThat(secondUpdate.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_TWO));

        // Verify epoch millis format
        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        assertThat(Long.parseLong(stored.item().get("lastUpdatedDateInEpochMillis").n()),
                   is(MOCKED_INSTANT_UPDATE_TWO.toEpochMilli()));

        table.deleteTable();
    }

    @Test
    public void putWithConditionExpression_updatesTimestampsWhenConditionMet() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        table.putItem(PutItemEnhancedRequest.builder(BasicRecord.class)
                                            .item(new BasicRecord().setId("id").setAttribute("one"))
                                            .conditionExpression(conditionExpression)
                                            .build());

        BasicRecord result = table.getItem(r -> r.key(k -> k.partitionValue("id")));
        assertThat(result.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));
        assertThat(result.getCreatedDate(), is(MOCKED_INSTANT_UPDATE_ONE)); // PutItem updates both

        table.deleteTable();
    }

    @Test
    public void updateWithConditionExpression_updatesTimestampsWhenConditionMet() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        BasicRecord result = table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one"))
                                                    .conditionExpression(conditionExpression));

        assertThat(result.getLastUpdatedDate(), is(MOCKED_INSTANT_UPDATE_ONE));
        assertThat(result.getCreatedDate(), is(MOCKED_INSTANT_NOW)); // UpdateItem preserves created date

        table.deleteTable();
    }

    @Test
    public void putWithFailedCondition_throwsException() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        thrown.expect(ConditionalCheckFailedException.class);
        table.putItem(PutItemEnhancedRequest.builder(BasicRecord.class)
                                            .item(new BasicRecord().setId("id").setAttribute("one"))
                                            .conditionExpression(conditionExpression)
                                            .build());

        table.deleteTable();
    }

    @Test
    public void updateWithFailedCondition_throwsException() {
        String tableName = getConcreteTableName("basic-record-table");
        DynamoDbTable<BasicRecord> table = enhancedClient.table(tableName, createBasicRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        thrown.expect(ConditionalCheckFailedException.class);
        table.updateItem(r -> r.item(new BasicRecord().setId("id").setAttribute("one"))
                               .conditionExpression(conditionExpression));

        table.deleteTable();
    }

    @Test
    public void putNewRecord_setsTimestampsOnAlNestedLevels() {
        String tableName = getConcreteTableName("nested-record-table");
        DynamoDbTable<NestedRecord> table = enhancedClient.table(tableName, createNestedRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        NestedBeanChild nestedLevel1 = new NestedBeanChild();

        NestedRecord item = new NestedRecord()
            .setId("id")
            .setAttribute("one")
            .setNestedRecord(nestedLevel1);

        table.putItem(r -> r.item(item));
        NestedRecord result = table.getItem(r -> r.key(k -> k.partitionValue("id")));

        // Verify nested level has timestamp set
        assertThat(result.getNestedRecord().getTime(), is(MOCKED_INSTANT_NOW));

        // Verify in DDB storage
        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        Map<String, AttributeValue> lvl1Map = stored.item().get("nestedRecord").m();
        assertThat(lvl1Map.get("time").s(), is(MOCKED_INSTANT_NOW.toString()));

        table.deleteTable();
    }

    @Test
    public void updateNestedRecord_updatesTimestampsOnAllLevels() {
        String tableName = getConcreteTableName("nested-record-table");
        DynamoDbTable<NestedRecord> table = enhancedClient.table(tableName, createNestedRecordSchema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        // Initial put
        table.putItem(r -> r.item(new NestedRecord().setId("id").setAttribute("one")
                                                    .setNestedRecord(new NestedBeanChild())));

        // First update
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        table.updateItem(r -> r.item(new NestedRecord().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedBeanChild())));

        GetItemResponse stored = getItemFromDDB(table.tableName(), "id");
        assertThat(stored.item().get("nestedRecord").m().get("time").s(), is(MOCKED_INSTANT_UPDATE_ONE.toString()));

        // Second update
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        table.updateItem(r -> r.item(new NestedRecord().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedBeanChild())));

        stored = getItemFromDDB(table.tableName(), "id");
        assertThat(stored.item().get("nestedRecord").m().get("time").s(), is(MOCKED_INSTANT_UPDATE_TWO.toString()));

        table.deleteTable();
    }

    @Test
    public void recursiveRecord_allTimestampsAreUpdated() {
        String tableName = getConcreteTableName("recursive-record-table");
        DynamoDbTable<RecursiveRecord> table = enhancedClient.table(tableName, createRecursiveRecordLevel1Schema());
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        RecursiveRecord level3 = new RecursiveRecord()
            .setId("l3_id");
        RecursiveRecord level2 = new RecursiveRecord()
            .setId("l2_id")
            .setChild(level3);
        RecursiveRecord level1 = new RecursiveRecord()
            .setId("l1_id")
            .setChild(level2);

        table.putItem(level1);

        GetItemResponse response = getItemFromDDB(table.tableName(), "l1_id");
        Map<String, AttributeValue> item = response.item();

        // Assert l1 timestamp is set
        assertNotNull(item.get("parentTimestamp"));
        assertEquals(MOCKED_INSTANT_NOW.toString(), item.get("parentTimestamp").s());

        // Assert l2 timestamp is set
        Map<String, AttributeValue> childMap = item.get("child").m();
        assertNotNull(childMap.get("childTimestamp"));
        assertEquals(MOCKED_INSTANT_NOW.toString(), childMap.get("childTimestamp").s());

        // Assert l3 timestamp is set
        Map<String, AttributeValue> grandchildMap = childMap.get("child").m();
        assertNotNull(grandchildMap.get("grandchildTimestamp"));
        assertEquals(MOCKED_INSTANT_NOW.toString(), grandchildMap.get("grandchildTimestamp").s());

        table.deleteTable();
    }

    @Test
    public void beanSchema_simpleRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("bean-simple-list-table");
        DynamoDbTable<SimpleBeanWithList> table = enhancedClient.table(tableName,
                                                                       BeanTableSchema.create(SimpleBeanWithList.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(
            new SimpleBeanWithList()
                .setId("1")
                .setChildList(Arrays.asList(
                    new AutogeneratedTimestampTestModels.SimpleBeanChild().setId("child1"),
                    new AutogeneratedTimestampTestModels.SimpleBeanChild().setId("child2"))));

        SimpleBeanWithList result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(0).getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(1).getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void beanSchema_simpleRecordWithSet_populatesTimestamps() {
        String tableName = getConcreteTableName("bean-simple-set-table");
        DynamoDbTable<SimpleBeanWithSet> table = enhancedClient.table(tableName,
                                                                      BeanTableSchema.create(SimpleBeanWithSet.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(
            new AutogeneratedTimestampTestModels.SimpleBeanWithSet()
                .setId("1")
                .setChildSet(new HashSet<>(Arrays.asList("child1", "child2"))));

        AutogeneratedTimestampTestModels.SimpleBeanWithSet result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildSet(), hasSize(2));
        assertThat(result.getChildSet().contains("child1"), is(true));
        assertThat(result.getChildSet().contains("child2"), is(true));

        table.deleteTable();
    }

    @Test
    public void beanSchema_simpleRecordWithMap_populatesTimestamps() {
        String tableName = getConcreteTableName("bean-simple-map-table");
        DynamoDbTable<AutogeneratedTimestampTestModels.SimpleBeanWithMap> table = enhancedClient.table(tableName,
                                                                                                       BeanTableSchema.create(AutogeneratedTimestampTestModels.SimpleBeanWithMap.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            new AutogeneratedTimestampTestModels.SimpleBeanWithMap()
                .setId("1")
                .setChildMap(new HashMap<String, String>() {{
                    put("child1", "attr_child1");
                    put("child2", "attr_child2");
                }}));

        SimpleBeanWithMap result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildMap().size(), is(2));
        assertThat(result.getChildMap().get("child1"), is("attr_child1"));
        assertThat(result.getChildMap().get("child2"), is("attr_child2"));

        table.deleteTable();
    }

    @Test
    public void beanSchema_nestedRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("bean-nested-list-table");
        DynamoDbTable<NestedBeanWithList> table = enhancedClient.table(tableName,
                                                                       BeanTableSchema.create(NestedBeanWithList.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            new NestedBeanWithList()
                .setId("1")
                .setLevel2(new NestedBeanChild()));

        NestedBeanWithList level1 = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(level1.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(level1.getLevel2().getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("immutable-simple-list-table");
        DynamoDbTable<SimpleImmutableRecordWithList> table = enhancedClient.table(tableName,
                                                                                  ImmutableTableSchema.create(SimpleImmutableRecordWithList.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            SimpleImmutableRecordWithList
                .builder()
                .id("1")
                .childList(Arrays.asList(
                    AutogeneratedTimestampTestModels.SimpleImmutableChild.builder().id("child1").build(),
                    AutogeneratedTimestampTestModels.SimpleImmutableChild.builder().id("child2").build()))
                .build());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(0).getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(1).getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecordWithSet_populatesTimestamps() {
        String tableName = getConcreteTableName("immutable-simple-set-table");
        DynamoDbTable<AutogeneratedTimestampTestModels.SimpleImmutableRecordWithSet> table = enhancedClient.table(tableName,
                                                                                                                  ImmutableTableSchema.create(SimpleImmutableRecordWithSet.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            AutogeneratedTimestampTestModels.SimpleImmutableRecordWithSet
                .builder()
                .id("1")
                .childSet(new HashSet<>(Arrays.asList("child1", "child2")))
                .build());

        AutogeneratedTimestampTestModels.SimpleImmutableRecordWithSet result = table.getItem(r -> r.key(k -> k.partitionValue(
            "1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildSet(), hasSize(2));
        assertThat(result.getChildSet().contains("child1"), is(true));
        assertThat(result.getChildSet().contains("child2"), is(true));

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecordWithMap_populatesTimestamps() {
        String tableName = getConcreteTableName("immutable-simple-map-table");
        DynamoDbTable<AutogeneratedTimestampTestModels.SimpleImmutableRecordWithMap> table = enhancedClient.table(tableName,
                                                                                                                  ImmutableTableSchema.create(SimpleImmutableRecordWithMap.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            AutogeneratedTimestampTestModels.SimpleImmutableRecordWithMap.builder()
                                                                         .id("1")
                                                                         .childMap(new HashMap<String, String>() {{
                                                                             put("child1", "attr_child1");
                                                                             put("child2", "attr_child2");
                                                                         }})
                                                                         .build());

        AutogeneratedTimestampTestModels.SimpleImmutableRecordWithMap result = table.getItem(r -> r.key(k -> k.partitionValue(
            "1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildMap().size(), is(2));
        assertThat(result.getChildMap().get("child1"), is("attr_child1"));
        assertThat(result.getChildMap().get("child2"), is("attr_child2"));

        table.deleteTable();
    }

    @Test
    public void immutableSchema_nestedRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("immutable-nested-list-table");
        DynamoDbTable<NestedImmutableRecordWithList> table = enhancedClient.table(tableName,
                                                                                  ImmutableTableSchema.create(NestedImmutableRecordWithList.class));
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            NestedImmutableRecordWithList
                .builder()
                .id("1")
                .level2(AutogeneratedTimestampTestModels.NestedImmutableChildRecordWithList.builder().build())
                .build()
        );

        NestedImmutableRecordWithList level1 = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(level1.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(level1.getLevel2().getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void staticSchema_simpleRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("static-simple-list-table");
        TableSchema<SimpleStaticRecordWithList> schema = buildStaticSchemaForSimpleRecordWithList();
        DynamoDbTable<SimpleStaticRecordWithList> table = enhancedClient.table(tableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(
            new SimpleStaticRecordWithList()
                .setId("1"));

        SimpleStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void staticSchema_nestedRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("static-nested-list-table");
        TableSchema<NestedStaticRecordWithList> schema = buildStaticSchemaForNestedRecordWithList();
        DynamoDbTable<NestedStaticRecordWithList> table = enhancedClient.table(tableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        table.putItem(
            new NestedStaticRecordWithList()
                .setId("1")
                .setLevel2(new AutogeneratedTimestampTestModels.NestedStaticChildRecordWithList()));

        NestedStaticRecordWithList level1 = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(level1.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(level1.getLevel2().getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_simpleRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("static-immutable-simple-list-table");
        TableSchema<SimpleImmutableRecordWithList> schema = buildStaticImmutableSchemaForSimpleRecordWithList();
        DynamoDbTable<SimpleImmutableRecordWithList> table = enhancedClient.table(tableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            SimpleImmutableRecordWithList
                .builder()
                .id("1")
                .childList(Arrays.asList(
                    AutogeneratedTimestampTestModels.SimpleImmutableChild.builder().id("child1").build(),
                    AutogeneratedTimestampTestModels.SimpleImmutableChild.builder().id("child2").build()))
                .build());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(result.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(0).getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(result.getChildList().get(1).getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_nestedRecordWithList_populatesTimestamps() {
        String tableName = getConcreteTableName("static-immutable-nested-list-table");
        TableSchema<NestedImmutableRecordWithList> schema = buildStaticImmutableSchemaForNestedRecordWithList();
        DynamoDbTable<NestedImmutableRecordWithList> table = enhancedClient.table(tableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(
            NestedImmutableRecordWithList
                .builder()
                .id("1")
                .level2(AutogeneratedTimestampTestModels.NestedImmutableChildRecordWithList.builder().build())
                .build());

        NestedImmutableRecordWithList level1 = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        assertThat(level1.getTime(), is(MOCKED_INSTANT_NOW));
        assertThat(level1.getLevel2().getTime(), is(MOCKED_INSTANT_NOW));

        table.deleteTable();
    }

    @Test
    public void autogenerateTimestamps_onNonInstantAttribute_throwsException() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute 'lastUpdatedDate' of Class type class java.lang.String is not a suitable "
                             + "Java Class type to be used as a Auto Generated Timestamp attribute. Only java.time."
                             + "Instant Class type is supported.");

        StaticTableSchema.builder(RecordWithStringUpdateDate.class)
                         .newItemSupplier(RecordWithStringUpdateDate::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(RecordWithStringUpdateDate::getId)
                                                           .setter(RecordWithStringUpdateDate::setId)
                                                           .tags(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("lastUpdatedDate")
                                                           .getter(RecordWithStringUpdateDate::getLastUpdatedDate)
                                                           .setter(RecordWithStringUpdateDate::setLastUpdatedDate)
                                                           .tags(autoGeneratedTimestampAttribute()))
                         .build();
    }

    @Test
    public void autogenerateTimestamps_onRootAttributeWithReservedMarker_throwsException() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'attr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        StaticTableSchema
            .builder(RecordWithInvalidAttributeNameOnRoot.class)
            .newItemSupplier(RecordWithInvalidAttributeNameOnRoot::new)
            .addAttribute(String.class,
                          a -> a.name("id")
                                .getter(RecordWithInvalidAttributeNameOnRoot::getId)
                                .setter(RecordWithInvalidAttributeNameOnRoot::setId)
                                .tags(primaryPartitionKey()))
            .addAttribute(Instant.class,
                          a -> a.name("attr_NESTED_ATTR_UPDATE_")
                                .getter(RecordWithInvalidAttributeNameOnRoot::getAttr_NESTED_ATTR_UPDATE_)
                                .setter(RecordWithInvalidAttributeNameOnRoot::setAttr_NESTED_ATTR_UPDATE_)
                                .tags(autoGeneratedTimestampAttribute()))
            .build();
    }

    @Test
    public void autogenerateTimestamps_onNestedAttributeWithReservedMarker_throwsException() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'childAttr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        StaticTableSchema
            .builder(RecordWithInvalidAttributeNameOnNestedLevel.class)
            .newItemSupplier(RecordWithInvalidAttributeNameOnNestedLevel::new)
            .addAttribute(
                String.class,
                a -> a.name("id")
                      .getter(RecordWithInvalidAttributeNameOnNestedLevel::getId)
                      .setter(RecordWithInvalidAttributeNameOnNestedLevel::setId)
                      .tags(primaryPartitionKey()))
            .addAttribute(
                EnhancedType.documentOf(
                    RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute.class,
                    StaticTableSchema
                        .builder(RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute.class)
                        .newItemSupplier(RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute::new)
                        .addAttribute(Instant.class,
                                      a -> a.name("childAttr_NESTED_ATTR_UPDATE_")
                                            .getter(RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute::getAttr_NESTED_ATTR_UPDATE_)
                                            .setter(RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute::setAttr_NESTED_ATTR_UPDATE_)
                                            .tags(autoGeneratedTimestampAttribute()))
                        .build()),
                a -> a.name("nestedChildAttribute")
                      .getter(RecordWithInvalidAttributeNameOnNestedLevel::getNestedChildAttribute)
                      .setter(RecordWithInvalidAttributeNameOnNestedLevel::setNestedChildAttribute))
            .build();
    }

    private GetItemResponse getItemFromDDB(String tableName, String id) {
        Map<String, AttributeValue> key = new HashMap<>();
        key.put("id", AttributeValue.builder().s(id).build());
        return getDynamoDbClient().getItem(GetItemRequest.builder()
                                                         .tableName(tableName)
                                                         .key(key)
                                                         .consistentRead(true)
                                                         .build());
    }


    /**
     * Basic record class for testing simple timestamp operations with multiple timestamp fields, different converters, and
     * flattened record structure.
     */
    private static class BasicRecord {
        private String id;
        private String attribute;
        private Instant createdDate;
        private Instant lastUpdatedDate;
        private Instant convertedLastUpdatedDate;
        private Instant lastUpdatedDateInEpochMillis;
        private FlattenedRecord flattenedRecord;

        public String getId() {
            return id;
        }

        public BasicRecord setId(String id) {
            this.id = id;
            return this;
        }

        public String getAttribute() {
            return attribute;
        }

        public BasicRecord setAttribute(String attribute) {
            this.attribute = attribute;
            return this;
        }

        public Instant getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        public BasicRecord setLastUpdatedDate(Instant lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        public Instant getCreatedDate() {
            return createdDate;
        }

        public BasicRecord setCreatedDate(Instant createdDate) {
            this.createdDate = createdDate;
            return this;
        }

        public Instant getConvertedLastUpdatedDate() {
            return convertedLastUpdatedDate;
        }

        public BasicRecord setConvertedLastUpdatedDate(Instant convertedLastUpdatedDate) {
            this.convertedLastUpdatedDate = convertedLastUpdatedDate;
            return this;
        }

        public Instant getLastUpdatedDateInEpochMillis() {
            return lastUpdatedDateInEpochMillis;
        }

        public BasicRecord setLastUpdatedDateInEpochMillis(Instant lastUpdatedDateInEpochMillis) {
            this.lastUpdatedDateInEpochMillis = lastUpdatedDateInEpochMillis;
            return this;
        }

        public FlattenedRecord getFlattenedRecord() {
            return flattenedRecord;
        }

        public BasicRecord setFlattenedRecord(FlattenedRecord flattenedRecord) {
            this.flattenedRecord = flattenedRecord;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            BasicRecord that = (BasicRecord) o;
            return Objects.equals(id, that.id) &&
                   Objects.equals(attribute, that.attribute) &&
                   Objects.equals(lastUpdatedDate, that.lastUpdatedDate) &&
                   Objects.equals(createdDate, that.createdDate) &&
                   Objects.equals(lastUpdatedDateInEpochMillis, that.lastUpdatedDateInEpochMillis) &&
                   Objects.equals(convertedLastUpdatedDate, that.convertedLastUpdatedDate) &&
                   Objects.equals(flattenedRecord, that.flattenedRecord);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, attribute, lastUpdatedDate, createdDate, lastUpdatedDateInEpochMillis,
                                convertedLastUpdatedDate, flattenedRecord);
        }
    }

    /**
     * Flattened record class for testing flattening functionality with auto-generated timestamps.
     */
    private static class FlattenedRecord {
        private Instant generated;

        public Instant getGenerated() {
            return generated;
        }

        public FlattenedRecord setGenerated(Instant generated) {
            this.generated = generated;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            FlattenedRecord that = (FlattenedRecord) o;
            return Objects.equals(generated, that.generated);
        }

        @Override
        public int hashCode() {
            return Objects.hash(generated);
        }
    }

    /**
     * Nested record class for testing nested timestamp operations with multiple timestamp fields and nested structure using
     * shared NestedBeanChild.
     */
    private static class NestedRecord {
        private String id;
        private String attribute;
        private Instant lastUpdatedDate;
        private Instant createdDate;
        private Instant lastUpdatedDateInEpochMillis;
        private Instant convertedLastUpdatedDate;
        private FlattenedRecord flattenedRecord;
        private NestedBeanChild nestedRecord;

        public String getId() {
            return id;
        }

        public NestedRecord setId(String id) {
            this.id = id;
            return this;
        }

        public String getAttribute() {
            return attribute;
        }

        public NestedRecord setAttribute(String attribute) {
            this.attribute = attribute;
            return this;
        }

        public Instant getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        public NestedRecord setLastUpdatedDate(Instant lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        public Instant getCreatedDate() {
            return createdDate;
        }

        public NestedRecord setCreatedDate(Instant createdDate) {
            this.createdDate = createdDate;
            return this;
        }

        public Instant getConvertedLastUpdatedDate() {
            return convertedLastUpdatedDate;
        }

        public NestedRecord setConvertedLastUpdatedDate(Instant convertedLastUpdatedDate) {
            this.convertedLastUpdatedDate = convertedLastUpdatedDate;
            return this;
        }

        public Instant getLastUpdatedDateInEpochMillis() {
            return lastUpdatedDateInEpochMillis;
        }

        public NestedRecord setLastUpdatedDateInEpochMillis(Instant lastUpdatedDateInEpochMillis) {
            this.lastUpdatedDateInEpochMillis = lastUpdatedDateInEpochMillis;
            return this;
        }

        public FlattenedRecord getFlattenedRecord() {
            return flattenedRecord;
        }

        public NestedRecord setFlattenedRecord(FlattenedRecord flattenedRecord) {
            this.flattenedRecord = flattenedRecord;
            return this;
        }

        public NestedBeanChild getNestedRecord() {
            return nestedRecord;
        }

        public NestedRecord setNestedRecord(NestedBeanChild nestedRecord) {
            this.nestedRecord = nestedRecord;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            NestedRecord that = (NestedRecord) o;
            return Objects.equals(id, that.id) &&
                   Objects.equals(attribute, that.attribute) &&
                   Objects.equals(lastUpdatedDate, that.lastUpdatedDate) &&
                   Objects.equals(createdDate, that.createdDate) &&
                   Objects.equals(lastUpdatedDateInEpochMillis, that.lastUpdatedDateInEpochMillis) &&
                   Objects.equals(convertedLastUpdatedDate, that.convertedLastUpdatedDate) &&
                   Objects.equals(flattenedRecord, that.flattenedRecord) &&
                   Objects.equals(nestedRecord, that.nestedRecord);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, attribute, lastUpdatedDate, createdDate, lastUpdatedDateInEpochMillis,
                                convertedLastUpdatedDate, flattenedRecord, nestedRecord);
        }
    }

    /**
     * Recursive record class for testing recursive timestamp operations with multiple timestamp fields at different nesting
     * levels.
     */
    private static class RecursiveRecord {
        private String id;
        private Instant parentTimestamp;
        private Instant childTimestamp;
        private RecursiveRecord child;

        public String getId() {
            return id;
        }

        public RecursiveRecord setId(String id) {
            this.id = id;
            return this;
        }

        public Instant getParentTimestamp() {
            return parentTimestamp;
        }

        public RecursiveRecord setParentTimestamp(Instant parentTimestamp) {
            this.parentTimestamp = parentTimestamp;
            return this;
        }

        public Instant getChildTimestamp() {
            return childTimestamp;
        }

        public RecursiveRecord setChildTimestamp(Instant childTimestamp) {
            this.childTimestamp = childTimestamp;
            return this;
        }

        public RecursiveRecord getChild() {
            return child;
        }

        public RecursiveRecord setChild(RecursiveRecord child) {
            this.child = child;
            return this;
        }

        @Override
        public final boolean equals(Object o) {
            if (!(o instanceof RecursiveRecord)) {
                return false;
            }

            RecursiveRecord that = (RecursiveRecord) o;
            return Objects.equals(id, that.id) && Objects.equals(parentTimestamp, that.parentTimestamp)
                   && Objects.equals(childTimestamp, that.childTimestamp) && Objects.equals(child, that.child);
        }

        @Override
        public int hashCode() {
            int result = Objects.hashCode(id);
            result = 31 * result + Objects.hashCode(parentTimestamp);
            result = 31 * result + Objects.hashCode(childTimestamp);
            result = 31 * result + Objects.hashCode(child);
            return result;
        }
    }

    /**
     * Record class for validation tests to ensure non-Instant types throw appropriate exceptions.
     */
    private static class RecordWithStringUpdateDate {
        private String id;
        private String lastUpdatedDate;

        public String getId() {
            return id;
        }

        public RecordWithStringUpdateDate setId(String id) {
            this.id = id;
            return this;
        }

        public String getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        public RecordWithStringUpdateDate setLastUpdatedDate(String lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            RecordWithStringUpdateDate that = (RecordWithStringUpdateDate) o;
            return Objects.equals(id, that.id) && Objects.equals(lastUpdatedDate, that.lastUpdatedDate);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, lastUpdatedDate);
        }
    }

    /**
     * Creates a table schema for FlattenedRecord with auto-generated timestamp attribute.
     *
     * @return TableSchema for FlattenedRecord
     */
    private TableSchema<FlattenedRecord> createFlattenedRecordSchema() {
        return StaticTableSchema.builder(FlattenedRecord.class)
                                .newItemSupplier(FlattenedRecord::new)
                                .addAttribute(Instant.class, a -> a.name("generated")
                                                                   .getter(FlattenedRecord::getGenerated)
                                                                   .setter(FlattenedRecord::setGenerated)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .build();
    }

    /**
     * Creates a comprehensive table schema for BasicRecord with multiple timestamp fields, different converters, and flattened
     * record structure.
     *
     * @return TableSchema for BasicRecord
     */
    private TableSchema<BasicRecord> createBasicRecordSchema() {
        TableSchema<FlattenedRecord> flattenedSchema = createFlattenedRecordSchema();

        return StaticTableSchema.builder(BasicRecord.class)
                                .newItemSupplier(BasicRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(BasicRecord::getId)
                                                                  .setter(BasicRecord::setId)
                                                                  .tags(primaryPartitionKey()))
                                .addAttribute(String.class, a -> a.name("attribute")
                                                                  .getter(BasicRecord::getAttribute)
                                                                  .setter(BasicRecord::setAttribute))
                                .addAttribute(Instant.class, a -> a.name("lastUpdatedDate")
                                                                   .getter(BasicRecord::getLastUpdatedDate)
                                                                   .setter(BasicRecord::setLastUpdatedDate)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(Instant.class, a -> a.name("createdDate")
                                                                   .getter(BasicRecord::getCreatedDate)
                                                                   .setter(BasicRecord::setCreatedDate)
                                                                   .tags(autoGeneratedTimestampAttribute(),
                                                                         updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                                .addAttribute(Instant.class, a -> a.name("lastUpdatedDateInEpochMillis")
                                                                   .getter(BasicRecord::getLastUpdatedDateInEpochMillis)
                                                                   .setter(BasicRecord::setLastUpdatedDateInEpochMillis)
                                                                   .attributeConverter(EpochMillisFormatTestConverter.create())
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(Instant.class, a -> a.name("convertedLastUpdatedDate")
                                                                   .getter(BasicRecord::getConvertedLastUpdatedDate)
                                                                   .setter(BasicRecord::setConvertedLastUpdatedDate)
                                                                   .attributeConverter(TimeFormatUpdateTestConverter.create())
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .flatten(flattenedSchema, BasicRecord::getFlattenedRecord, BasicRecord::setFlattenedRecord)
                                .build();
    }

    /**
     * Creates a table schema for NestedRecord with multiple timestamp fields and nested structure.
     *
     * @return TableSchema for NestedRecord
     */
    private TableSchema<NestedRecord> createNestedRecordSchema() {
        TableSchema<FlattenedRecord> flattenedSchema = createFlattenedRecordSchema();

        return StaticTableSchema.builder(NestedRecord.class)
                                .newItemSupplier(NestedRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(NestedRecord::getId)
                                                                  .setter(NestedRecord::setId)
                                                                  .tags(primaryPartitionKey()))
                                .addAttribute(String.class, a -> a.name("attribute")
                                                                  .getter(NestedRecord::getAttribute)
                                                                  .setter(NestedRecord::setAttribute))
                                .addAttribute(Instant.class, a -> a.name("lastUpdatedDate")
                                                                   .getter(NestedRecord::getLastUpdatedDate)
                                                                   .setter(NestedRecord::setLastUpdatedDate)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(Instant.class, a -> a.name("createdDate")
                                                                   .getter(NestedRecord::getCreatedDate)
                                                                   .setter(NestedRecord::setCreatedDate)
                                                                   .tags(autoGeneratedTimestampAttribute(),
                                                                         updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                                .addAttribute(Instant.class, a -> a.name("lastUpdatedDateInEpochMillis")
                                                                   .getter(NestedRecord::getLastUpdatedDateInEpochMillis)
                                                                   .setter(NestedRecord::setLastUpdatedDateInEpochMillis)
                                                                   .attributeConverter(EpochMillisFormatTestConverter.create())
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(Instant.class, a -> a.name("convertedLastUpdatedDate")
                                                                   .getter(NestedRecord::getConvertedLastUpdatedDate)
                                                                   .setter(NestedRecord::setConvertedLastUpdatedDate)
                                                                   .attributeConverter(TimeFormatUpdateTestConverter.create())
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .flatten(flattenedSchema, NestedRecord::getFlattenedRecord, NestedRecord::setFlattenedRecord)
                                .addAttribute(EnhancedType.documentOf(NestedBeanChild.class,
                                                                      BeanTableSchema.create(NestedBeanChild.class),
                                                                      b -> b.ignoreNulls(true)),
                                              a -> a.name("nestedRecord")
                                                    .getter(NestedRecord::getNestedRecord)
                                                    .setter(NestedRecord::setNestedRecord))
                                .build();
    }

    /**
     * Creates a table schema for the deepest level (Level 3) of recursive records.
     *
     * @return TableSchema for RecursiveRecord Level 3
     */
    private TableSchema<RecursiveRecord> createRecursiveRecordLevel3Schema() {
        return StaticTableSchema.builder(RecursiveRecord.class)
                                .newItemSupplier(RecursiveRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(RecursiveRecord::getId)
                                                                  .setter(RecursiveRecord::setId)
                                                                  .tags(primaryPartitionKey()))
                                .addAttribute(Instant.class, a -> a.name("grandchildTimestamp")
                                                                   .getter(RecursiveRecord::getChildTimestamp)
                                                                   .setter(RecursiveRecord::setChildTimestamp)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .build();
    }

    /**
     * Creates a table schema for the middle level (Level 2) of recursive records.
     *
     * @return TableSchema for RecursiveRecord Level 2
     */
    private TableSchema<RecursiveRecord> createRecursiveRecordLevel2Schema() {
        TableSchema<RecursiveRecord> level3Schema = createRecursiveRecordLevel3Schema();

        return StaticTableSchema.builder(RecursiveRecord.class)
                                .newItemSupplier(RecursiveRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(RecursiveRecord::getId)
                                                                  .setter(RecursiveRecord::setId)
                                                                  .tags(primaryPartitionKey()))
                                .addAttribute(Instant.class, a -> a.name("childTimestamp")
                                                                   .getter(RecursiveRecord::getChildTimestamp)
                                                                   .setter(RecursiveRecord::setChildTimestamp)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(EnhancedType.documentOf(RecursiveRecord.class, level3Schema),
                                              a -> a.name("child")
                                                    .getter(RecursiveRecord::getChild)
                                                    .setter(RecursiveRecord::setChild))
                                .build();
    }

    /**
     * Creates a table schema for the top level (Level 1) of recursive records.
     *
     * @return TableSchema for RecursiveRecord Level 1
     */
    private TableSchema<RecursiveRecord> createRecursiveRecordLevel1Schema() {
        TableSchema<RecursiveRecord> level2Schema = createRecursiveRecordLevel2Schema();

        return StaticTableSchema.builder(RecursiveRecord.class)
                                .newItemSupplier(RecursiveRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(RecursiveRecord::getId)
                                                                  .setter(RecursiveRecord::setId)
                                                                  .tags(primaryPartitionKey()))
                                .addAttribute(Instant.class, a -> a.name("parentTimestamp")
                                                                   .getter(RecursiveRecord::getParentTimestamp)
                                                                   .setter(RecursiveRecord::setParentTimestamp)
                                                                   .tags(autoGeneratedTimestampAttribute()))
                                .addAttribute(EnhancedType.documentOf(RecursiveRecord.class, level2Schema),
                                              a -> a.name("child")
                                                    .getter(RecursiveRecord::getChild)
                                                    .setter(RecursiveRecord::setChild))
                                .build();
    }
}