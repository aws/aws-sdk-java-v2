/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests.extensions;

import static org.assertj.core.api.Assertions.assertThat;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.Order.FIRST;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.Order.SECOND;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.LocalDynamoDbSyncTestBase;
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver;
import software.amazon.awssdk.enhanced.dynamodb.mapper.Order;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;

public class AutoGeneratedKeyCompositeGsiTest extends LocalDynamoDbSyncTestBase {

    private static final TableSchema<BeanWithMixedCompositeGsi> TABLE_SCHEMA =
        TableSchema.fromClass(BeanWithMixedCompositeGsi.class);

    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(Stream.concat(
                                                    ExtensionResolver.defaultExtensions().stream(),
                                                    Stream.of(AutoGeneratedKeyExtension.create()))
                                                .collect(Collectors.toList()))
                              .build();

    private final DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
        enhancedClient.table(getConcreteTableName("mixed-gsi-autogenerated-key-table"), TABLE_SCHEMA);

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(r -> r.tableName(
            getConcreteTableName("mixed-gsi-autogenerated-key-table")));
    }

    @Test
    public void putItem_whenKeysNotPopulated_generatesNewUuids() {
        BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();

        mappedTable.putItem(record);
        BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream()
                                                      .findFirst()
                                                      .orElseThrow(() -> new AssertionError("No record found"));

        assertAllKeysAreValidUuids(result);
    }

    @Test
    public void putItem_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated();
        mappedTable.putItem(record);

        BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream()
                                                      .findFirst()
                                                      .orElseThrow(() -> new AssertionError("No record found"));

        assertCompositeKeyValuesArePreserved(result);
    }

    @Test
    public void updateItem_respectsUpdateBehavior() {
        BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated();

        // put item with all keys populated
        mappedTable.putItem(record);
        BeanWithMixedCompositeGsi afterPut =
            mappedTable.scan().items().stream()
                       .findFirst()
                       .orElseThrow(() -> new AssertionError("No record found"));

        String originalPk = afterPut.getId();
        String originalSk = afterPut.getSort();
        String originalRootPartitionKey1 = afterPut.getRootPartitionKey1();
        String originalRootPartitionKey2 = afterPut.getRootPartitionKey2();
        String originalRootSortKey1 = afterPut.getRootSortKey1();
        String originalRootSortKey2 = afterPut.getRootSortKey2();
        String originalFlattenedPartitionKey1 = afterPut.getFlattenedKeys().flattenedPartitionKey1;
        String originalFlattenedPartitionKey2 = afterPut.getFlattenedKeys().flattenedPartitionKey2;
        String originalFlattenedSortKey1 = afterPut.getFlattenedKeys().flattenedSortKey1;
        String originalFlattenedSortKey2 = afterPut.getFlattenedKeys().flattenedSortKey2;

        // update item
        BeanWithMixedCompositeGsi update = new BeanWithMixedCompositeGsi();
        update.setId(afterPut.getId());
        update.setSort(afterPut.getSort());

        mappedTable.updateItem(update);
        BeanWithMixedCompositeGsi afterUpdate =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSort())));


        assertAllKeysAreValidUuids(afterUpdate);

        // id and sort preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
        assertThat(afterUpdate.getId()).isEqualTo(originalPk);
        assertThat(afterUpdate.getSort()).isEqualTo(originalSk);

        // rootPartitionKey1, rootSortKey1, flattenedPartitionKey1, flattenedSortKey1 have WRITE_ALWAYS
        // ->  regenerates UUID on every update
        assertThat(afterUpdate.getRootPartitionKey1()).isNotEqualTo(originalRootPartitionKey1);
        assertThat(afterUpdate.getRootSortKey1()).isNotEqualTo(originalRootSortKey1);
        assertThat(afterUpdate.getFlattenedKeys().flattenedPartitionKey1).isNotEqualTo(originalFlattenedPartitionKey1);
        assertThat(afterUpdate.getFlattenedKeys().flattenedSortKey1).isNotEqualTo(originalFlattenedSortKey1);

        // rootPartitionKey2, rootSortKey2, flattenedPartitionKey2, flattenedSortKey2 have WRITE_IF_NOT_EXISTS
        // ->  preserves original UUID, only writes if null
        assertThat(afterUpdate.getRootPartitionKey2()).isEqualTo(originalRootPartitionKey2);
        assertThat(afterUpdate.getRootSortKey2()).isEqualTo(originalRootSortKey2);
        assertThat(afterUpdate.getFlattenedKeys().getFlattenedPartitionKey2()).isEqualTo(originalFlattenedPartitionKey2);
        assertThat(afterUpdate.getFlattenedKeys().getFlattenedSortKey2()).isEqualTo(originalFlattenedSortKey2);
    }

    @Test
    public void batchWrite_onBean_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithMixedCompositeGsi firstRecord = buildBeanWithCompositeGsiAndKeysPopulated(1);
        BeanWithMixedCompositeGsi secondRecord = buildBeanWithCompositeGsiAndKeysPopulated(2);

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(BeanWithMixedCompositeGsi.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));

        List<BeanWithMixedCompositeGsi> results = mappedTable.scan().items().stream().collect(Collectors.toList());

        assertThat(results.size()).isEqualTo(2);
        assertAllKeysAreValidUuids(results.get(0));
        assertAllKeysAreValidUuids(results.get(1));
    }

    @Test
    public void batchWrite_onBean_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithMixedCompositeGsi firstRecord = buildBeanWithCompositeGsiAndKeysPopulated(1);
        BeanWithMixedCompositeGsi secondRecord = buildBeanWithCompositeGsiAndKeysPopulated(2);

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(WriteBatch.builder(BeanWithMixedCompositeGsi.class)
                                                                         .mappedTableResource(mappedTable)
                                                                         .addPutItem(firstRecord)
                                                                         .addPutItem(secondRecord)
                                                                         .build()));

        BeanWithMixedCompositeGsi firstSavedRecord =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_1").sortValue("existing-sort_1")));
        assertCompositeKeyValuesArePreserved(firstSavedRecord, 1);

        BeanWithMixedCompositeGsi secondSavedRecord =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_2").sortValue("existing-sort_2")));
        assertCompositeKeyValuesArePreserved(secondSavedRecord, 2);
    }

    @Test
    public void transactWrite_onBean_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();
        enhancedClient.transactWriteItems(TransactWriteItemsEnhancedRequest.builder()
                                                                           .addPutItem(mappedTable, record)
                                                                           .build());

        BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream().findFirst()
                                                      .orElseThrow(() -> new AssertionError("No record found"));

        assertAllKeysAreValidUuids(result);
    }

    @Test
    public void transactWrite_onBean_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated();
        enhancedClient.transactWriteItems(TransactWriteItemsEnhancedRequest.builder()
                                                                           .addPutItem(mappedTable, record)
                                                                           .build());

        BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream().findFirst()
                                                      .orElseThrow(() -> new AssertionError("No record found"));

        assertCompositeKeyValuesArePreserved(result);
    }

    private static void assertAllKeysAreValidUuids(BeanWithMixedCompositeGsi record) {
        isValidUuid(record.getId());
        isValidUuid(record.getSort());
        isValidUuid(record.getRootPartitionKey1());
        isValidUuid(record.getRootPartitionKey2());
        isValidUuid(record.getRootSortKey1());
        isValidUuid(record.getRootSortKey2());
        isValidUuid(record.getFlattenedKeys().flattenedPartitionKey1);
        isValidUuid(record.getFlattenedKeys().flattenedPartitionKey2);
        isValidUuid(record.getFlattenedKeys().flattenedSortKey1);
        isValidUuid(record.getFlattenedKeys().flattenedSortKey2);
    }

    private static void assertCompositeKeyValuesArePreserved(BeanWithMixedCompositeGsi actual) {
        assertCompositeKeyValuesArePreserved(actual, null);
    }

    private static void assertCompositeKeyValuesArePreserved(BeanWithMixedCompositeGsi actual, Integer recordIndex) {
        String suffix = recordIndex == null ? "" : "_" + recordIndex;

        assertThat(actual.getId()).isEqualTo("existing-id" + suffix);
        assertThat(actual.getSort()).isEqualTo("existing-sort" + suffix);
        assertThat(actual.getRootPartitionKey1()).isEqualTo("existing-rootPk1" + suffix);
        assertThat(actual.getRootPartitionKey2()).isEqualTo("existing-rootPk2" + suffix);
        assertThat(actual.getRootSortKey1()).isEqualTo("existing-rootSk1" + suffix);
        assertThat(actual.getRootSortKey2()).isEqualTo("existing-rootSk2" + suffix);

        assertThat(actual.getFlattenedKeys().flattenedPartitionKey1).isEqualTo("existing-flattenedPk1" + suffix);
        assertThat(actual.getFlattenedKeys().flattenedPartitionKey2).isEqualTo("existing-flattenedPk2" + suffix);
        assertThat(actual.getFlattenedKeys().flattenedSortKey1).isEqualTo("existing-flattenedSk1" + suffix);
        assertThat(actual.getFlattenedKeys().flattenedSortKey2).isEqualTo("existing-flattenedSk2" + suffix);
    }

    private static BeanWithMixedCompositeGsi buildBeanWithCompositeGsiAndKeysPopulated() {
        return buildBeanWithCompositeGsiAndKeysPopulated(null);
    }

    private static BeanWithMixedCompositeGsi buildBeanWithCompositeGsiAndKeysPopulated(Integer index) {
        String suffix = index == null ? "" : "_" + index;

        BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();
        record.setId("existing-id" + suffix);
        record.setSort("existing-sort" + suffix);
        record.setRootPartitionKey1("existing-rootPk1" + suffix);
        record.setRootPartitionKey2("existing-rootPk2" + suffix);
        record.setRootSortKey1("existing-rootSk1" + suffix);
        record.setRootSortKey2("existing-rootSk2" + suffix);

        BeanWithMixedCompositeGsi.FlattenedKeys flattenedKeys = new BeanWithMixedCompositeGsi.FlattenedKeys();
        flattenedKeys.setFlattenedPartitionKey1("existing-flattenedPk1" + suffix);
        flattenedKeys.setFlattenedPartitionKey2("existing-flattenedPk2" + suffix);
        flattenedKeys.setFlattenedSortKey1("existing-flattenedSk1" + suffix);
        flattenedKeys.setFlattenedSortKey2("existing-flattenedSk2" + suffix);
        record.setFlattenedKeys(flattenedKeys);

        return record;
    }

    @DynamoDbBean
    public static class BeanWithMixedCompositeGsi {
        private String id;
        private String sort;
        private String rootPartitionKey1;
        private String rootPartitionKey2;
        private String rootSortKey1;
        private String rootSortKey2;
        private FlattenedKeys flattenedKeys;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSort() {
            return sort;
        }

        public void setSort(String sort) {
            this.sort = sort;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi", "mixed_sort_gsi"}, order = FIRST)
        public String getRootPartitionKey1() {
            return rootPartitionKey1;
        }

        public void setRootPartitionKey1(String rootPartitionKey1) {
            this.rootPartitionKey1 = rootPartitionKey1;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi", "mixed_sort_gsi"}, order = SECOND)
        public String getRootPartitionKey2() {
            return rootPartitionKey2;
        }

        public void setRootPartitionKey2(String rootPartitionKey2) {
            this.rootPartitionKey2 = rootPartitionKey2;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = FIRST)
        public String getRootSortKey1() {
            return rootSortKey1;
        }

        public void setRootSortKey1(String rootSortKey1) {
            this.rootSortKey1 = rootSortKey1;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = SECOND)
        public String getRootSortKey2() {
            return rootSortKey2;
        }

        public void setRootSortKey2(String rootSortKey2) {
            this.rootSortKey2 = rootSortKey2;
        }

        @DynamoDbFlatten
        public FlattenedKeys getFlattenedKeys() {
            return flattenedKeys;
        }

        public void setFlattenedKeys(FlattenedKeys flattenedKeys) {
            this.flattenedKeys = flattenedKeys;
        }

        @DynamoDbBean
        public static class FlattenedKeys {
            private String flattenedPartitionKey1;
            private String flattenedPartitionKey2;
            private String flattenedSortKey1;
            private String flattenedSortKey2;

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
            @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi"}, order = Order.THIRD)
            public String getFlattenedPartitionKey1() {
                return flattenedPartitionKey1;
            }

            public void setFlattenedPartitionKey1(String flattenedPartitionKey1) {
                this.flattenedPartitionKey1 = flattenedPartitionKey1;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
            @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi"}, order = Order.FOURTH)
            public String getFlattenedPartitionKey2() {
                return flattenedPartitionKey2;
            }

            public void setFlattenedPartitionKey2(String flattenedPartitionKey2) {
                this.flattenedPartitionKey2 = flattenedPartitionKey2;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
            @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = Order.THIRD)
            public String getFlattenedSortKey1() {
                return flattenedSortKey1;
            }

            public void setFlattenedSortKey1(String flattenedSortKey1) {
                this.flattenedSortKey1 = flattenedSortKey1;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
            @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = Order.FOURTH)
            public String getFlattenedSortKey2() {
                return flattenedSortKey2;
            }

            public void setFlattenedSortKey2(String flattenedSortKey2) {
                this.flattenedSortKey2 = flattenedSortKey2;
            }
        }
    }
}


