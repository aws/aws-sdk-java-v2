/*
 * Copyright Amazon.com, Inc. or its affiliates.
 * Licensed under the Apache License, Version 2.0.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.AutoGeneratedUuidRecordTest.assertValidUuid;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primarySortKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondarySortKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.updateBehavior;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import org.assertj.core.api.Assertions;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedUuidExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedUuid;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbVersionAttribute;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;

/**
 * Tests for @DynamoDbAutoGeneratedKey annotation functionality.
 * <p>
 * Tests cover: - Basic UUID generation on all 4 key types (primary PK/SK, GSI PK/SK) - UpdateBehavior control (WRITE_ALWAYS vs
 * WRITE_IF_NOT_EXISTS) for secondary index keys - Primary key limitations (UpdateBehavior has no effect) - Error handling for
 * invalid usage - Integration with other extensions (VersionedRecord)
 */
@RunWith(Parameterized.class)
public class AutoGeneratedKeyRecordTest extends LocalDynamoDbSyncTestBase {

    private final DynamoDbTable<TestRecord> mappedTable;

    public AutoGeneratedKeyRecordTest(String testName, TableSchema<TestRecord> schema) {
        this.mappedTable = DynamoDbEnhancedClient.builder()
                                                 .dynamoDbClient(getDynamoDbClient())
                                                 .extensions(AutoGeneratedKeyExtension.create())
                                                 .build()
                                                 .table(getConcreteTableName("AutoGenKey-table"), schema);
    }

    @Parameters(name = "{index}: {0}")
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][] {
            {"StaticTableSchema", createStaticSchema()},
            {"BeanTableSchema", TableSchema.fromBean(TestRecord.class)}
        });
    }

    private static TableSchema<TestRecord> createStaticSchema() {
        return StaticTableSchema.builder(TestRecord.class)
                                .newItemSupplier(TestRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(TestRecord::getId)
                                                                  .setter(TestRecord::setId)
                                                                  .tags(primaryPartitionKey(),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("sortKey")
                                                                  .getter(TestRecord::getSortKey)
                                                                  .setter(TestRecord::setSortKey)
                                                                  .tags(primarySortKey(),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("gsiPk")
                                                                  .getter(TestRecord::getGsiPk)
                                                                  .setter(TestRecord::setGsiPk)
                                                                  .tags(secondaryPartitionKey("gsi1"),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("gsiSk")
                                                                  .getter(TestRecord::getGsiSk)
                                                                  .setter(TestRecord::setGsiSk)
                                                                  .tags(secondarySortKey("gsi1"),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute(),
                                                                        updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                                .addAttribute(String.class, a -> a.name("payload")
                                                                  .getter(TestRecord::getPayload)
                                                                  .setter(TestRecord::setPayload))
                                .build();
    }

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        mappedTable.deleteTable();
    }

    @Test
    public void putItem_generatesUuidsForAllFourKeyTypes() {
        TestRecord record = new TestRecord();
        mappedTable.putItem(record);

        TestRecord retrieved = mappedTable.scan().items().stream().findFirst()
                                          .orElseThrow(() -> new AssertionError("No record found"));

        // Verify all 4 key types are generated
        assertValidUuid(retrieved.getId());      // Primary partition key
        assertValidUuid(retrieved.getSortKey()); // Primary sort key
        assertValidUuid(retrieved.getGsiPk());   // GSI partition key
        assertValidUuid(retrieved.getGsiSk());   // GSI sort key

        // Verify they're all unique keys
        assertThat(retrieved.getId()).isNotEqualTo(retrieved.getSortKey());
        assertThat(retrieved.getGsiPk()).isNotEqualTo(retrieved.getGsiSk());
        assertThat(retrieved.getId()).isNotEqualTo(retrieved.getGsiPk());
    }

    @Test
    public void updateItem_respectsUpdateBehaviorForSecondaryIndexKeys() {
        // Put record
        TestRecord record = new TestRecord();
        mappedTable.putItem(record);

        TestRecord afterPut = mappedTable.scan().items().stream().findFirst()
                                         .orElseThrow(() -> new AssertionError("No record found"));
        String id = afterPut.getId();
        String sortKey = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();  // WRITE_ALWAYS (default) → should change
        String originalGsiSk = afterPut.getGsiSk();  // WRITE_IF_NOT_EXISTS    → should preserve

        // Update record
        TestRecord updateRecord = new TestRecord();
        updateRecord.setId(id);
        updateRecord.setSortKey(sortKey);
        updateRecord.setPayload("updated");
        mappedTable.updateItem(updateRecord);

        TestRecord afterUpdate = mappedTable.getItem(r -> r.key(k -> k.partitionValue(id).sortValue(sortKey)));
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk); // Regenerated
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);    // Preserved
        assertEquals("updated", afterUpdate.getPayload());
    }

    @Test
    public void putItem_withAutogeneratedKeySetOnNonKeyAttribute_throwsException() {
        String tableName = getConcreteTableName("invalid-usage-test");
        DynamoDbEnhancedClient client = createClient();

        TableSchema<InvalidUsageRecord> schema = StaticTableSchema.builder(InvalidUsageRecord.class)
                                                                  .newItemSupplier(InvalidUsageRecord::new)
                                                                  .addAttribute(String.class, a -> a.name("id")
                                                                                                    .getter(InvalidUsageRecord::getId)
                                                                                                    .setter(InvalidUsageRecord::setId)
                                                                                                    .addTag(primaryPartitionKey()))
                                                                  .addAttribute(String.class, a -> a.name("notAKey")
                                                                                                    .getter(InvalidUsageRecord::getNotAKey)
                                                                                                    .setter(InvalidUsageRecord::setNotAKey)
                                                                                                    .addTag(AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                                                  .build();

        DynamoDbTable<InvalidUsageRecord> table = client.table(tableName, schema);

        try {
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            InvalidUsageRecord record = new InvalidUsageRecord();
            record.setId("test-id");

            Assertions.assertThatExceptionOfType(IllegalArgumentException.class)
                      .isThrownBy(() -> table.putItem(record))
                      .withMessage(
                          "@DynamoDbAutoGeneratedKey can only be applied to key attributes: "
                          + "primary partition key, primary sort key, or GSI/LSI partition/sort keys. "
                          + "Invalid placement on attribute: notAKey");
        } finally {
            deleteTableByName(tableName);
        }
    }

    @Test
    public void versionedRecord_worksWithAutoGeneratedKeys() {
        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        String tableName = getConcreteTableName("versioned-test");
        DynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()
                                                              .dynamoDbClient(getDynamoDbClient())
                                                              .extensions(
                                                                  AutoGeneratedKeyExtension.builder().build(),
                                                                  VersionedRecordExtension.builder().build())
                                                              .build();

        DynamoDbTable<VersionedRecord> table = client.table(tableName, TableSchema.fromBean(VersionedRecord.class));

        try {
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            VersionedRecord record = new VersionedRecord();
            record.setPayload("initial");
            table.putItem(record);

            VersionedRecord retrieved = table.scan().items().stream().findFirst()
                                             .orElseThrow(() -> new AssertionError("No record found"));

            assertValidUuid(retrieved.getId());
            assertEquals("initial", retrieved.getPayload());
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            // Update to test versioning still works
            retrieved.setPayload("updated");
            VersionedRecord updated = table.updateItem(retrieved);
            assertEquals("updated", updated.getPayload());
            assertThat(updated.getVersion()).isEqualTo(2L);
        } finally {
            deleteTableByName(tableName);
        }
    }

    @Test
    public void autogeneratedConflictingAnnotations_throwsException() {
        String tableName = getConcreteTableName("conflicting-annotations-test");
        DynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()
                                                              .dynamoDbClient(getDynamoDbClient())
                                                              .extensions(
                                                                  AutoGeneratedKeyExtension.create(),
                                                                  AutoGeneratedUuidExtension.create())
                                                              .build();

        try {
            DynamoDbTable<ConflictingAnnotationsRecord> table =
                client.table(tableName, TableSchema.fromBean(ConflictingAnnotationsRecord.class));
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            ConflictingAnnotationsRecord record = new ConflictingAnnotationsRecord();
            record.setPayload("test");

            Assertions
                .assertThatExceptionOfType(IllegalArgumentException.class)
                .isThrownBy(() -> table.putItem(record))
                .withMessage(
                    "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                    + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
        } finally {
            deleteTableByName(tableName);
        }
    }


    // ========== Transactional Write Operations Tests ==========
    @Test
    public void transactWrite_generatesKeysForMultipleOperations() {
        TestRecord putRecord = new TestRecord();
        putRecord.setPayload("transact-put");
        TestRecord updateRecord = new TestRecord();
        updateRecord.setPayload("transact-update");

        DynamoDbEnhancedClient client = createClient();
        client.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, putRecord)
                                             .addUpdateItem(mappedTable, updateRecord)
                                             .build());

        List<TestRecord> allRecords = mappedTable.scan().items().stream().collect(Collectors.toList());
        assertThat(allRecords).hasSize(2);
        allRecords.forEach(this::assertAllKeysGenerated);
    }

    @Test
    public void transactWrite_preservesExistingKeysAndGeneratesMissing() {
        TestRecord record = new TestRecord();
        record.setId("existing-id");
        record.setGsiPk("existing-gsi-pk");
        record.setPayload("transact-preserve");

        DynamoDbEnhancedClient client = createClient();
        client.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        TestRecord retrieved = mappedTable.scan().items().stream().findFirst()
                                          .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(retrieved.getId()).isEqualTo("existing-id");
        assertThat(retrieved.getGsiPk()).isEqualTo("existing-gsi-pk");
        assertValidUuid(retrieved.getSortKey());
        assertValidUuid(retrieved.getGsiSk());
    }


    // ========== Batch Write Operations Tests ==========
    @Test
    public void batchWrite_generatesAllMissingKeys() {
        TestRecord record1 = new TestRecord();
        record1.setPayload("batch1");
        TestRecord record2 = new TestRecord();
        record2.setPayload("batch2");

        DynamoDbEnhancedClient client = createClient();
        client.batchWriteItem(r -> r.addWriteBatch(
            WriteBatch.builder(TestRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(record1)
                      .addPutItem(record2)
                      .build()));

        List<TestRecord> allRecords = mappedTable.scan().items().stream().collect(Collectors.toList());
        assertThat(allRecords).hasSize(2);
        allRecords.forEach(this::assertAllKeysGenerated);
    }

    @Test
    public void batchWrite_preservesExistingKeysAndGeneratesMissing() {
        TestRecord record = new TestRecord();
        record.setId("existing-id");
        record.setSortKey("existing-sort");
        record.setPayload("batch-preserve");

        DynamoDbEnhancedClient client = createClient();
        client.batchWriteItem(r -> r.addWriteBatch(
            WriteBatch.builder(TestRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(record)
                      .build()));

        TestRecord retrieved = mappedTable.scan().items().stream().findFirst()
                                          .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(retrieved.getId()).isEqualTo("existing-id");
        assertThat(retrieved.getSortKey()).isEqualTo("existing-sort");
        assertValidUuid(retrieved.getGsiPk());
        assertValidUuid(retrieved.getGsiSk());
    }

    @Test
    public void batchWrite_mixedPutDeleteOperations() {
        TestRecord existingRecord = new TestRecord();
        existingRecord.setId("to-delete");
        existingRecord.setSortKey("to-delete-sort");
        mappedTable.putItem(existingRecord);

        TestRecord newRecord = new TestRecord();
        newRecord.setPayload("batch-mixed");

        DynamoDbEnhancedClient client = createClient();
        client.batchWriteItem(r -> r.addWriteBatch(
            WriteBatch.builder(TestRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(newRecord)
                      .addDeleteItem(b -> b.key(k -> k.partitionValue("to-delete").sortValue("to-delete-sort")))
                      .build()));

        List<TestRecord> allRecords = mappedTable.scan().items().stream().collect(Collectors.toList());
        assertThat(allRecords).hasSize(1);

        TestRecord remaining = allRecords.get(0);
        assertAllKeysGenerated(remaining);
        assertThat(remaining.getPayload()).isEqualTo("batch-mixed");
    }

    private DynamoDbEnhancedClient createClient() {
        return DynamoDbEnhancedClient.builder()
                                     .dynamoDbClient(getDynamoDbClient())
                                     .extensions(AutoGeneratedKeyExtension.create())
                                     .build();
    }

    private void deleteTableByName(String tableName) {
        getDynamoDbClient().deleteTable(b -> b.tableName(tableName));
    }

    private void assertAllKeysGenerated(TestRecord record) {
        assertValidUuid(record.getId());
        assertValidUuid(record.getSortKey());
        assertValidUuid(record.getGsiPk());
        assertValidUuid(record.getGsiSk());
    }

    @DynamoDbBean
    public static class TestRecord {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;
        private String payload;

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }

    public static class InvalidUsageRecord {
        private String id;
        private String notAKey;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getNotAKey() {
            return notAKey;
        }

        public void setNotAKey(String notAKey) {
            this.notAKey = notAKey;
        }
    }

    @DynamoDbBean
    public static class VersionedRecord {
        private String id;
        private Long version;
        private String payload;

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }

    @DynamoDbBean
    public static class ConflictingAnnotationsRecord {
        private String id;
        private String payload;

        // Both annotations on the same field - should cause an exception
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        @DynamoDbAutoGeneratedUuid
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }
}