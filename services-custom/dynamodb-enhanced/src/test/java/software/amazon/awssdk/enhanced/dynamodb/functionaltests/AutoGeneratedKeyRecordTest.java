/*
 * Copyright Amazon.com, Inc. or its affiliates.
 * Licensed under the Apache License, Version 2.0.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.AutoGeneratedUuidRecordTest.assertValidUuid;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primarySortKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.secondarySortKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.updateBehavior;

import java.util.Arrays;
import java.util.Collection;
import org.assertj.core.api.Assertions;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedUuidExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedUuid;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbVersionAttribute;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;

/**
 * Tests for @DynamoDbAutoGeneratedKey annotation functionality.
 * <p>
 * Tests cover: - Basic UUID generation on all 4 key types (primary PK/SK, GSI PK/SK) - UpdateBehavior control (WRITE_ALWAYS vs
 * WRITE_IF_NOT_EXISTS) for secondary index keys - Primary key limitations (UpdateBehavior has no effect) - Error handling for
 * invalid usage - Integration with other extensions (VersionedRecord)
 */
@RunWith(Parameterized.class)
public class AutoGeneratedKeyRecordTest extends LocalDynamoDbSyncTestBase {

    private final DynamoDbTable<TestRecord> mappedTable;

    public AutoGeneratedKeyRecordTest(String testName, TableSchema<TestRecord> schema) {
        this.mappedTable = DynamoDbEnhancedClient.builder()
                                                 .dynamoDbClient(getDynamoDbClient())
                                                 .extensions(AutoGeneratedKeyExtension.builder().build())
                                                 .build()
                                                 .table(getConcreteTableName("AutoGenKey-table"), schema);
    }

    @Parameters(name = "{index}: {0}")
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][] {
            {"StaticTableSchema", createStaticSchema()},
            {"BeanTableSchema", TableSchema.fromBean(TestRecord.class)}
        });
    }

    private static TableSchema<TestRecord> createStaticSchema() {
        return StaticTableSchema.builder(TestRecord.class)
                                .newItemSupplier(TestRecord::new)
                                .addAttribute(String.class, a -> a.name("id")
                                                                  .getter(TestRecord::getId)
                                                                  .setter(TestRecord::setId)
                                                                  .tags(primaryPartitionKey(),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("sortKey")
                                                                  .getter(TestRecord::getSortKey)
                                                                  .setter(TestRecord::setSortKey)
                                                                  .tags(primarySortKey(),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("gsiPk")
                                                                  .getter(TestRecord::getGsiPk)
                                                                  .setter(TestRecord::setGsiPk)
                                                                  .tags(secondaryPartitionKey("gsi1"),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                .addAttribute(String.class, a -> a.name("gsiSk")
                                                                  .getter(TestRecord::getGsiSk)
                                                                  .setter(TestRecord::setGsiSk)
                                                                  .tags(secondarySortKey("gsi1"),
                                                                        AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute(),
                                                                        updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                                .addAttribute(String.class, a -> a.name("payload")
                                                                  .getter(TestRecord::getPayload)
                                                                  .setter(TestRecord::setPayload))
                                .build();
    }

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        mappedTable.deleteTable();
    }

    @Test
    public void putItem_generatesUuidsForAllFourKeyTypes() {
        TestRecord record = new TestRecord();
        // Don't set any keys - they should all be auto-generated
        mappedTable.putItem(record);

        TestRecord retrieved = mappedTable.scan().items().stream().findFirst()
                                          .orElseThrow(() -> new AssertionError("No record found"));

        // Verify all 4 key types are generated
        assertValidUuid(retrieved.getId());      // Primary partition key
        assertValidUuid(retrieved.getSortKey()); // Primary sort key
        assertValidUuid(retrieved.getGsiPk());   // GSI partition key
        assertValidUuid(retrieved.getGsiSk());   // GSI sort key

        // Verify they're all different
        assertThat(retrieved.getId()).isNotEqualTo(retrieved.getSortKey());
        assertThat(retrieved.getGsiPk()).isNotEqualTo(retrieved.getGsiSk());
        assertThat(retrieved.getId()).isNotEqualTo(retrieved.getGsiPk());
    }

    @Test
    public void updateItem_respectsUpdateBehaviorForSecondaryIndexKeys() {
        // Put initial record
        TestRecord record = new TestRecord();
        mappedTable.putItem(record);

        TestRecord afterPut = mappedTable.scan().items().stream().findFirst()
                                         .orElseThrow(() -> new AssertionError("No record found"));
        String id = afterPut.getId();
        String sortKey = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();  // WRITE_ALWAYS (default) → should change
        String originalGsiSk = afterPut.getGsiSk();  // WRITE_IF_NOT_EXISTS → should preserve

        // Update record
        TestRecord updateRecord = new TestRecord();
        updateRecord.setId(id);
        updateRecord.setSortKey(sortKey);
        updateRecord.setPayload("updated");
        mappedTable.updateItem(updateRecord);

        TestRecord afterUpdate = mappedTable.getItem(r -> r.key(k -> k.partitionValue(id).sortValue(sortKey)));
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk); // Regenerated
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);    // Preserved
        assertEquals("updated", afterUpdate.getPayload());
    }

    @Test
    public void nonKeyAttribute_throwsException() {
        String tableName = getConcreteTableName("invalid-usage-test");
        DynamoDbEnhancedClient client = createClient();

        TableSchema<InvalidUsageRecord> schema = StaticTableSchema.builder(InvalidUsageRecord.class)
                                                                  .newItemSupplier(InvalidUsageRecord::new)
                                                                  .addAttribute(String.class, a -> a.name("id")
                                                                                                    .getter(InvalidUsageRecord::getId)
                                                                                                    .setter(InvalidUsageRecord::setId)
                                                                                                    .addTag(primaryPartitionKey()))
                                                                  .addAttribute(String.class, a -> a.name("notAKey")
                                                                                                    .getter(InvalidUsageRecord::getNotAKey)
                                                                                                    .setter(InvalidUsageRecord::setNotAKey)
                                                                                                    .addTag(AutoGeneratedKeyExtension.AttributeTags.autoGeneratedKeyAttribute()))
                                                                  .build();

        DynamoDbTable<InvalidUsageRecord> table = client.table(tableName, schema);

        try {
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            InvalidUsageRecord record = new InvalidUsageRecord();
            record.setId("test-id");

            Assertions.assertThatExceptionOfType(IllegalArgumentException.class)
                      .isThrownBy(() -> table.putItem(record))
                      .withMessageContaining("@DynamoDbAutoGeneratedKey can only be applied to key attributes")
                      .withMessageContaining("notAKey");
        } finally {
            deleteTableByName(tableName);
        }
    }

    @Test
    public void versionedRecord_worksWithAutoGeneratedKeys() {
        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        String tableName = getConcreteTableName("versioned-test");
        DynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()
                                                              .dynamoDbClient(getDynamoDbClient())
                                                              .extensions(AutoGeneratedKeyExtension.builder().build(),
                                                                          VersionedRecordExtension.builder().build())
                                                              .build();

        DynamoDbTable<VersionedRecord> table = client.table(tableName, TableSchema.fromBean(VersionedRecord.class));

        try {
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            VersionedRecord record = new VersionedRecord();
            record.setPayload("initial");
            table.putItem(record);

            VersionedRecord retrieved = table.scan().items().stream().findFirst()
                                             .orElseThrow(() -> new AssertionError("No record found"));

            assertValidUuid(retrieved.getId());
            assertEquals("initial", retrieved.getPayload());
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            // Update to test versioning still works
            retrieved.setPayload("updated");
            VersionedRecord updated = table.updateItem(retrieved);
            assertEquals("updated", updated.getPayload());
            assertThat(updated.getVersion()).isEqualTo(2L);
        } finally {
            deleteTableByName(tableName);
        }
    }

    @Test
    public void conflictingAnnotations_throwsException() {
        String tableName = getConcreteTableName("conflicting-annotations-test");
        DynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()
                                                              .dynamoDbClient(getDynamoDbClient())
                                                              .extensions(AutoGeneratedKeyExtension.builder().build(),
                                                                          AutoGeneratedUuidExtension.create())
                                                              .build();

        try {
            DynamoDbTable<ConflictingAnnotationsRecord> table =
                client.table(tableName, TableSchema.fromBean(ConflictingAnnotationsRecord.class));
            table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            ConflictingAnnotationsRecord record = new ConflictingAnnotationsRecord();
            record.setPayload("test");

            Assertions
                .assertThatExceptionOfType(IllegalArgumentException.class)
                .isThrownBy(() -> table.putItem(record))
                .withMessage("Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid "
                             + "annotations. "
                             + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
        } finally {
            deleteTableByName(tableName);
        }
    }


    private DynamoDbEnhancedClient createClient() {
        return DynamoDbEnhancedClient.builder()
                                     .dynamoDbClient(getDynamoDbClient())
                                     .extensions(AutoGeneratedKeyExtension.builder().build())
                                     .build();
    }

    private void deleteTableByName(String tableName) {
        getDynamoDbClient().deleteTable(b -> b.tableName(tableName));
    }

    @DynamoDbBean
    public static class TestRecord {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;
        private String payload;

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }

    public static class InvalidUsageRecord {
        private String id;
        private String notAKey;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getNotAKey() {
            return notAKey;
        }

        public void setNotAKey(String notAKey) {
            this.notAKey = notAKey;
        }
    }

    @DynamoDbBean
    public static class VersionedRecord {
        private String id;
        private Long version;
        private String payload;

        // NOTE: UpdateBehavior has no effect on primary keys since they cannot be null in DynamoDB
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }

    @DynamoDbBean
    public static class ConflictingAnnotationsRecord {
        private String id;
        private String payload;

        // Both annotations on the same field - should cause an exception
        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        @DynamoDbAutoGeneratedUuid
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }
}