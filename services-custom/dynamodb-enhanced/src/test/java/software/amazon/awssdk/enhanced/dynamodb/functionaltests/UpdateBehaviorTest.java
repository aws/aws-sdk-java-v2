package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.InvalidNestedAttributeBean.InvalidNestedAttributeChild;

import com.google.common.collect.ImmutableList;
import java.time.Instant;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.CompositeRecord;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.FlattenRecord;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.InvalidNestedAttributeBean;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.InvalidRootAttributeBean;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedRecordWithUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithUpdateBehaviors;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.TimestampListElement;
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver;
import software.amazon.awssdk.enhanced.dynamodb.model.IgnoreNullsMode;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.DynamoDbException;
import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;

public class UpdateBehaviorTest extends LocalDynamoDbSyncTestBase {
    private static final Instant INSTANT_1 = Instant.parse("2020-05-03T10:00:00Z");
    private static final Instant INSTANT_2 = Instant.parse("2020-05-03T10:05:00Z");
    private static final Instant FAR_FUTURE_INSTANT = Instant.parse("9999-05-03T10:05:00Z");
    private static final String TEST_BEHAVIOUR_ATTRIBUTE = "testBehaviourAttribute";
    private static final String TEST_ATTRIBUTE = "testAttribute";

    private static final TableSchema<RecordWithUpdateBehaviors> TABLE_SCHEMA =
        TableSchema.fromClass(RecordWithUpdateBehaviors.class);

    private static final TableSchema<FlattenRecord> TABLE_SCHEMA_FLATTEN_RECORD =
        TableSchema.fromClass(FlattenRecord.class);

    private static final TableSchema<InvalidRootAttributeBean> TABLE_SCHEMA_INVALID_ATTR_NAME_ON_ROOT =
        TableSchema.fromClass(InvalidRootAttributeBean.class);

    private static final TableSchema<InvalidNestedAttributeBean> TABLE_SCHEMA_INVALID_ATTR_NAME_ON_NESTED_LEVEL =
        TableSchema.fromClass(InvalidNestedAttributeBean.class);

    private final DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder()
                                                                                .dynamoDbClient(getDynamoDbClient()).extensions(
            Stream.concat(ExtensionResolver.defaultExtensions().stream(),
                          Stream.of(AutoGeneratedTimestampRecordExtension.create())).collect(Collectors.toList()))
                                                                                .build();

    private final DynamoDbTable<RecordWithUpdateBehaviors> mappedTable =
        enhancedClient.table(getConcreteTableName("table-name"), TABLE_SCHEMA);

    private final DynamoDbTable<FlattenRecord> flattenedMappedTable =
        enhancedClient.table(getConcreteTableName("table-name"), TABLE_SCHEMA_FLATTEN_RECORD);

    private final DynamoDbTable<InvalidRootAttributeBean> beanWithInvalidRootAttrNameMappedTable =
        enhancedClient.table(getConcreteTableName("table-name"), TABLE_SCHEMA_INVALID_ATTR_NAME_ON_ROOT);

    private final DynamoDbTable<InvalidNestedAttributeBean> beanWithInvalidNestedAttrNameMappedTable =
        enhancedClient.table(getConcreteTableName("table-name"), TABLE_SCHEMA_INVALID_ATTR_NAME_ON_NESTED_LEVEL);

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(r -> r.tableName(getConcreteTableName("table-name")));
    }

    @Test
    public void updateBehaviors_firstUpdate() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = new NestedRecordWithUpdateBehavior();
        nestedRecord.setId("id167");
        nestedRecord.setNestedUpdateBehaviorAttribute(TEST_BEHAVIOUR_ATTRIBUTE);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setCreatedOn(INSTANT_1);
        record.setLastUpdatedOn(INSTANT_2);
        record.setNestedRecord(nestedRecord);
        mappedTable.updateItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(record);

        assertThat(persistedRecord.getVersion()).isEqualTo(1L);

        assertThat(persistedRecord.getCreatedOn()).isEqualTo(INSTANT_1);
        assertThat(persistedRecord.getLastUpdatedOn()).isEqualTo(INSTANT_2);
        assertThat(persistedRecord.getLastAutoUpdatedOn()).isAfterOrEqualTo(currentTime);
        assertThat(persistedRecord.getFormattedLastAutoUpdatedOn().getEpochSecond())
            .isGreaterThanOrEqualTo(currentTime.getEpochSecond());

        assertThat(persistedRecord.getLastAutoUpdatedOnMillis().getEpochSecond()).isGreaterThanOrEqualTo(currentTime.getEpochSecond());
        assertThat(persistedRecord.getCreatedAutoUpdateOn()).isAfterOrEqualTo(currentTime);

        assertThat(persistedRecord.getNestedRecord().getId()).isEqualTo("id167");
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isAfterOrEqualTo(currentTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isAfterOrEqualTo(currentTime);
        assertThat(persistedRecord.getCreatedAutoUpdateOn()).isAfterOrEqualTo(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute());
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isEqualTo(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute());
    }

    @Test
    public void updateBehaviors_secondUpdate() {
        Instant beforeUpdateInstant = Instant.now().minusMillis(1);

        NestedRecordWithUpdateBehavior secondNestedRecord = new NestedRecordWithUpdateBehavior();
        secondNestedRecord.setId("id199");
        secondNestedRecord.setNestedUpdateBehaviorAttribute(TEST_BEHAVIOUR_ATTRIBUTE);

        NestedRecordWithUpdateBehavior nestedRecord = new NestedRecordWithUpdateBehavior();
        nestedRecord.setId("id155");
        nestedRecord.setNestedUpdateBehaviorAttribute(TEST_BEHAVIOUR_ATTRIBUTE);
        nestedRecord.setNestedRecord(secondNestedRecord);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setCreatedOn(INSTANT_1);
        record.setLastUpdatedOn(INSTANT_2);
        record.setNestedRecord(nestedRecord);
        mappedTable.updateItem(record);
        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(record);

        assertThat(persistedRecord.getVersion()).isEqualTo(1L);

        Instant firstUpdatedTime = persistedRecord.getLastAutoUpdatedOn();
        Instant createdAutoUpdateOn = persistedRecord.getCreatedAutoUpdateOn();

        assertThat(firstUpdatedTime).isAfterOrEqualTo(beforeUpdateInstant);
        assertThat(persistedRecord.getFormattedLastAutoUpdatedOn().getEpochSecond())
            .isGreaterThanOrEqualTo(beforeUpdateInstant.getEpochSecond());
        assertThat(persistedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isNotNull();
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute())
            .isEqualTo(firstUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute())
            .isEqualTo(firstUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedRecord().getNestedCreatedTimeAttribute())
            .isEqualTo(firstUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedRecord().getNestedUpdatedTimeAttribute())
            .isEqualTo(firstUpdatedTime);

        record.setVersion(1L);
        record.setCreatedOn(INSTANT_2);
        record.setLastUpdatedOn(INSTANT_2);
        record.setNestedRecord(nestedRecord);
        mappedTable.updateItem(record);

        persistedRecord = mappedTable.getItem(record);
        assertThat(persistedRecord.getVersion()).isEqualTo(2L);
        assertThat(persistedRecord.getCreatedOn()).isEqualTo(INSTANT_1);
        assertThat(persistedRecord.getLastUpdatedOn()).isEqualTo(INSTANT_2);

        Instant secondUpdatedTime = persistedRecord.getLastAutoUpdatedOn();
        assertThat(secondUpdatedTime).isAfterOrEqualTo(firstUpdatedTime);
        assertThat(persistedRecord.getCreatedAutoUpdateOn()).isEqualTo(createdAutoUpdateOn);
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute())
            .isEqualTo(secondUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute())
            .isEqualTo(secondUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedRecord().getNestedCreatedTimeAttribute())
            .isEqualTo(secondUpdatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedRecord().getNestedUpdatedTimeAttribute())
            .isEqualTo(secondUpdatedTime);
    }

    @Test
    public void updateBehaviors_removal() {
        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setCreatedOn(INSTANT_1);
        record.setLastUpdatedOn(INSTANT_2);
        record.setLastAutoUpdatedOn(FAR_FUTURE_INSTANT);
        mappedTable.updateItem(record);
        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(record);
        Instant createdAutoUpdateOn = persistedRecord.getCreatedAutoUpdateOn();
        assertThat(persistedRecord.getLastAutoUpdatedOn()).isBefore(FAR_FUTURE_INSTANT);

        record.setVersion(1L);
        record.setCreatedOn(null);
        record.setLastUpdatedOn(null);
        record.setLastAutoUpdatedOn(null);
        mappedTable.updateItem(record);

        persistedRecord = mappedTable.getItem(record);
        assertThat(persistedRecord.getCreatedOn()).isNull();
        assertThat(persistedRecord.getLastUpdatedOn()).isNull();
        assertThat(persistedRecord.getLastAutoUpdatedOn()).isNotNull();
        assertThat(persistedRecord.getCreatedAutoUpdateOn()).isEqualTo(createdAutoUpdateOn);
    }

    @Test
    public void updateBehaviors_transactWriteItems_secondUpdate() {
        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setCreatedOn(INSTANT_1);
        record.setLastUpdatedOn(INSTANT_2);
        record.setLastAutoUpdatedOn(INSTANT_2);
        RecordWithUpdateBehaviors firstUpdatedRecord = mappedTable.updateItem(record);

        record.setVersion(1L);
        record.setCreatedOn(INSTANT_2);
        record.setLastUpdatedOn(INSTANT_2);
        record.setLastAutoUpdatedOn(INSTANT_2);
        enhancedClient.transactWriteItems(r -> r.addUpdateItem(mappedTable, record));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(record);
        assertThat(persistedRecord.getCreatedOn()).isEqualTo(INSTANT_1);
        assertThat(persistedRecord.getLastUpdatedOn()).isEqualTo(INSTANT_2);
        assertThat(persistedRecord.getLastAutoUpdatedOn()).isAfterOrEqualTo(INSTANT_2);
        assertThat(persistedRecord.getCreatedAutoUpdateOn()).isEqualTo(firstUpdatedRecord.getCreatedAutoUpdateOn());
    }

    @Test
    public void when_updatingNestedObjectWithSingleLevel_existingInformationIsPreserved_scalar_only_update() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        Instant nestedCreatedTime = persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute();
        Instant nestedUpdatedTime = persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute();
        assertThat(nestedCreatedTime).isAfter(currentTime);
        assertThat(nestedUpdatedTime).isEqualTo(nestedCreatedTime);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();
        long updatedNestedCounter = 10L;
        updatedNestedRecord.setNestedCounter(updatedNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifySingleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), updatedNestedCounter,
                                                       TEST_BEHAVIOUR_ATTRIBUTE, currentTime);
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isEqualTo(nestedCreatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isAfter(nestedUpdatedTime);
    }

    @Test
    public void when_updatingNestedObjectWithSingleLevel_default_mode_update_newMapCreated() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        Instant nestedCreatedTime = persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute();
        Instant nestedUpdatedTime = persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute();
        assertThat(nestedCreatedTime).isNotNull();
        assertThat(nestedUpdatedTime).isEqualTo(nestedCreatedTime);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();
        long updatedNestedCounter = 10L;
        updatedNestedRecord.setNestedCounter(updatedNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.DEFAULT));

        persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifySingleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), updatedNestedCounter, null,
                                                       currentTime);
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isAfter(nestedCreatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isAfter(nestedUpdatedTime);
    }

    @Test
    public void when_updatingNestedObjectWithSingleLevel_with_no_mode_update_newMapCreated() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);

        mappedTable.putItem(record);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();
        long updatedNestedCounter = 10L;
        updatedNestedRecord.setNestedCounter(updatedNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);

        mappedTable.updateItem(r -> r.item(updateRecord));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifySingleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), updatedNestedCounter, null,
                                                       currentTime);
    }

    @Test
    public void when_updatingNestedObjectList_no_matter_mode_update_newListCreated_with_timestampGenerated() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);
        nestedRecord.setNestedUpdatedTimeAttribute(null);
        TimestampListElement firstElement = new TimestampListElement();
        firstElement.setId("id1");
        firstElement.setAttribute("attr1");
        TimestampListElement secondElement = new TimestampListElement();
        secondElement.setId("id2");
        secondElement.setAttribute("attr2");
        nestedRecord.setNestedRecordList(ImmutableList.of(firstElement, secondElement));

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);
        record.setNestedRecordList(ImmutableList.of(firstElement, secondElement));

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        List<TimestampListElement> nestedRecordList = persistedRecord.getNestedRecord().getNestedRecordList();
        Instant firstOperationTime = nestedRecordList.get(0).getTimeAttributeElement();

        assertThat(persistedRecord.getNestedRecordList().get(0).getTimeAttributeElement()).isAfter(currentTime);
        assertThat(persistedRecord.getNestedRecordList().get(1).getTimeAttributeElement()).isAfter(currentTime);
        assertThat(nestedRecordList.get(0).getTimeAttributeElement()).isAfter(currentTime);
        assertThat(nestedRecordList.get(1).getTimeAttributeElement()).isEqualTo(firstOperationTime);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();
        long updatedNestedCounter = 10L;
        updatedNestedRecord.setNestedUpdatedTimeAttribute(null);
        firstElement.setAttribute("attr44");
        secondElement.setAttribute("attr55");
        updatedNestedRecord.setNestedCounter(updatedNestedCounter);
        updatedNestedRecord.setNestedRecordList(ImmutableList.of(firstElement, secondElement));

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);
        updateRecord.setNestedRecordList(ImmutableList.of(firstElement));

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        nestedRecordList = persistedRecord.getNestedRecord().getNestedRecordList();

        assertThat(persistedRecord.getNestedRecordList()).hasSize(1);
        assertThat(persistedRecord.getNestedRecordList().get(0).getTimeAttributeElement()).isAfter(firstOperationTime);
        assertThat(nestedRecordList).hasSize(2);
        assertThat(nestedRecordList.get(0).getTimeAttributeElement()).isAfter(firstOperationTime);
        assertThat(nestedRecordList.get(1).getTimeAttributeElement()).isAfter(firstOperationTime);
    }

    @Test
    public void when_updatingNestedObjectToEmptyWithSingleLevel_existingInformationIsPreserved_scalar_only_update() {

        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);
        nestedRecord.setAttribute(TEST_ATTRIBUTE);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);

        mappedTable.putItem(record);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));
        assertThat(persistedRecord.getNestedRecord()).isNotNull();
        assertThat(persistedRecord.getNestedRecord().getId()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedCounter()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isNotNull();
    }

    @Test
    public void when_updatingNestedObjectWithSingleLevel_updateBehaviorIsChecked_scalar_only_update() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord);

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        Instant nestedCreatedTime = persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute();
        Instant nestedUpdatedTime = persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute();
        assertThat(nestedCreatedTime).isAfter(currentTime);
        assertThat(nestedUpdatedTime).isEqualTo(nestedCreatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isEqualTo(TEST_BEHAVIOUR_ATTRIBUTE);

        NestedRecordWithUpdateBehavior updatedNestedRecord = new NestedRecordWithUpdateBehavior();
        long updatedNestedCounter = 10L;
        updatedNestedRecord.setNestedCounter(updatedNestedCounter);
        updatedNestedRecord.setNestedUpdateBehaviorAttribute(TEST_BEHAVIOUR_ATTRIBUTE + "updated");

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        //WRITE_IF_NOT_EXISTS detected on createdTimeAttribute and updateBehaviorAttribute -> not changed
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isEqualTo(nestedCreatedTime);
        assertThat(persistedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isEqualTo(TEST_BEHAVIOUR_ATTRIBUTE);

        assertThat(persistedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isAfter(nestedUpdatedTime);
    }

    private NestedRecordWithUpdateBehavior createNestedWithDefaults(String id, Long counter) {
        NestedRecordWithUpdateBehavior nestedRecordWithDefaults = new NestedRecordWithUpdateBehavior();
        nestedRecordWithDefaults.setId(id);
        nestedRecordWithDefaults.setNestedCounter(counter);
        nestedRecordWithDefaults.setNestedUpdateBehaviorAttribute(TEST_BEHAVIOUR_ATTRIBUTE);

        return nestedRecordWithDefaults;
    }

    private void verifyMultipleLevelNestingTargetedUpdateBehavior(NestedRecordWithUpdateBehavior nestedRecord,
                                                                  long updatedOuterNestedCounter,
                                                                  long updatedInnerNestedCounter,
                                                                  String testBehaviorAttribute,
                                                                  Instant expectedTime) {
        assertThat(nestedRecord).isNotNull();
        assertThat(nestedRecord.getNestedRecord()).isNotNull();

        assertThat(nestedRecord.getNestedCounter()).isEqualTo(updatedOuterNestedCounter);
        assertThat(nestedRecord.getNestedCreatedTimeAttribute()).isAfter(expectedTime);
        assertThat(nestedRecord.getNestedUpdatedTimeAttribute()).isAfter(expectedTime);
        assertThat(nestedRecord.getNestedRecord()).isNotNull();
        assertThat(nestedRecord.getNestedRecord().getNestedCounter()).isEqualTo(updatedInnerNestedCounter);
        assertThat(nestedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isEqualTo(
            testBehaviorAttribute);
        assertThat(nestedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isAfter(expectedTime);
        assertThat(nestedRecord.getNestedRecord().getNestedUpdatedTimeAttribute()).isAfter(expectedTime);
    }

    private void verifySingleLevelNestingTargetedUpdateBehavior(NestedRecordWithUpdateBehavior nestedRecord,
                                                                long updatedNestedCounter, String expectedBehaviorAttr,
                                                                Instant expectedTime) {
        assertThat(nestedRecord).isNotNull();
        assertThat(nestedRecord.getNestedCounter()).isEqualTo(updatedNestedCounter);
        assertThat(nestedRecord.getNestedUpdateBehaviorAttribute()).isEqualTo(expectedBehaviorAttr);
        assertThat(nestedRecord.getNestedCreatedTimeAttribute()).isAfter(expectedTime);
        assertThat(nestedRecord.getNestedUpdatedTimeAttribute()).isAfter(expectedTime);
    }

    @Test
    public void when_updatingNestedObjectWithMultipleLevels_inScalarOnlyMode_existingInformationIsPreserved() {
        NestedRecordWithUpdateBehavior nestedRecord1 = createNestedWithDefaults("id789", 50L);

        NestedRecordWithUpdateBehavior nestedRecord2 = createNestedWithDefaults("id456", 0L);
        nestedRecord2.setNestedRecord(nestedRecord1);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord2);

        mappedTable.putItem(record);

        NestedRecordWithUpdateBehavior updatedNestedRecord2 = new NestedRecordWithUpdateBehavior();
        long innerNestedCounter = 100L;
        updatedNestedRecord2.setNestedCounter(innerNestedCounter);

        NestedRecordWithUpdateBehavior updatedNestedRecord1 = new NestedRecordWithUpdateBehavior();
        updatedNestedRecord1.setNestedRecord(updatedNestedRecord2);
        long outerNestedCounter = 200L;
        updatedNestedRecord1.setNestedCounter(outerNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord1);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifyMultipleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), outerNestedCounter,
                                                         innerNestedCounter, TEST_BEHAVIOUR_ATTRIBUTE, INSTANT_1);
    }

    @Test
    public void when_updatingNestedObjectWithMultipleLevels_inMapsOnlyMode_existingInformationIsPreserved() {
        NestedRecordWithUpdateBehavior nestedRecord1 = createNestedWithDefaults("id789", 50L);

        NestedRecordWithUpdateBehavior nestedRecord2 = createNestedWithDefaults("id456", 0L);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord2);

        mappedTable.putItem(record);

        NestedRecordWithUpdateBehavior updatedNestedRecord1 = new NestedRecordWithUpdateBehavior();
        updatedNestedRecord1.setNestedRecord(nestedRecord1);
        long outerNestedCounter = 200L;
        updatedNestedRecord1.setNestedCounter(outerNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord1);

        mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.MAPS_ONLY));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifyMultipleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), outerNestedCounter,
                                                         50L, TEST_BEHAVIOUR_ATTRIBUTE, INSTANT_1);
    }

    @Test
    public void when_updatingNestedObjectWithMultipleLevels_default_mode_existingInformationIsErased() {
        Instant currentTime = Instant.now().minusMillis(1);
        NestedRecordWithUpdateBehavior nestedRecord1 = createNestedWithDefaults("id789", 50L);

        NestedRecordWithUpdateBehavior nestedRecord2 = createNestedWithDefaults("id456", 0L);
        nestedRecord2.setNestedRecord(nestedRecord1);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setNestedRecord(nestedRecord2);

        mappedTable.putItem(record);

        NestedRecordWithUpdateBehavior updatedNestedRecord2 = new NestedRecordWithUpdateBehavior();
        long innerNestedCounter = 100L;
        updatedNestedRecord2.setNestedCounter(innerNestedCounter);

        NestedRecordWithUpdateBehavior updatedNestedRecord1 = new NestedRecordWithUpdateBehavior();
        updatedNestedRecord1.setNestedRecord(updatedNestedRecord2);
        long outerNestedCounter = 200L;
        updatedNestedRecord1.setNestedCounter(outerNestedCounter);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setNestedRecord(updatedNestedRecord1);

        mappedTable.updateItem(r -> r.item(updateRecord));

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id123")));

        verifyMultipleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), outerNestedCounter,
                                                         innerNestedCounter, null,
                                                         currentTime);
    }

    @Test
    public void when_updatingNestedNonScalarObject_scalar_only_update_throwsDynamoDBException() {
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);
        nestedRecord.setAttribute(TEST_ATTRIBUTE);

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setKey("abc");
        updateRecord.setNestedRecord(nestedRecord);

        assertThatThrownBy(() -> mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY)))
            .isInstanceOf(DynamoDbException.class);
    }

    @Test
    public void when_updatingNestedMap_mapsOnlyMode_newMapIsCreatedAndStored() {
        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");

        mappedTable.putItem(record);

        RecordWithUpdateBehaviors updateRecord = new RecordWithUpdateBehaviors();
        updateRecord.setId("id123");
        updateRecord.setVersion(1L);
        updateRecord.setKey("abc");

        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id456", 5L);
        nestedRecord.setAttribute(TEST_ATTRIBUTE);
        updateRecord.setNestedRecord(nestedRecord);

        RecordWithUpdateBehaviors persistedRecord =
            mappedTable.updateItem(r -> r.item(updateRecord).ignoreNullsMode(IgnoreNullsMode.MAPS_ONLY));

        verifySingleLevelNestingTargetedUpdateBehavior(persistedRecord.getNestedRecord(), 5L, TEST_BEHAVIOUR_ATTRIBUTE,
                                                       INSTANT_1);
        assertThat(persistedRecord.getNestedRecord().getAttribute()).isEqualTo(TEST_ATTRIBUTE);
    }

    @Test
    public void when_emptyNestedRecordIsSet_emptyMapIsStoredInTable() {
        String key = "id123";

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId(key);
        record.setNestedRecord(new NestedRecordWithUpdateBehavior());

        mappedTable.updateItem(r -> r.item(record));

        GetItemResponse getItemResponse = getDynamoDbClient().getItem(GetItemRequest.builder()
                                                                                    .key(Collections.singletonMap("id",
                                                                                                                  AttributeValue.fromS(key)))
                                                                                    .tableName(getConcreteTableName("table-name"))
                                                                                    .build());

        assertThat(getItemResponse.item().get("nestedRecord")).isNotNull();
        Map<String, AttributeValue> nestedRecord = getItemResponse.item().get("nestedRecord").m();
        assertThat(nestedRecord.get("nestedCreatedTimeAttribute")).isNotNull();
        assertThat(nestedRecord.get("nestedUpdatedTimeAttribute")).isNotNull();
        assertTrue(nestedRecord.get("id").nul());
        assertTrue(nestedRecord.get("nestedRecord").nul());
        assertTrue(nestedRecord.get("attribute").nul());
        assertTrue(nestedRecord.get("nestedUpdateBehaviorAttribute").nul());
        assertTrue(nestedRecord.get("nestedCounter").nul());
        assertTrue(nestedRecord.get("nestedVersionedAttribute").nul());
    }


    @Test
    public void when_updatingNestedObjectWithSingleLevelFlattened_existingInformationIsPreserved_scalar_only_update() {
        NestedRecordWithUpdateBehavior nestedRecord = createNestedWithDefaults("id123", 10L);

        CompositeRecord compositeRecord = new CompositeRecord();
        compositeRecord.setNestedRecord(nestedRecord);

        FlattenRecord flattenRecord = new FlattenRecord();
        flattenRecord.setCompositeRecord(compositeRecord);
        flattenRecord.setId("id456");

        flattenedMappedTable.putItem(r -> r.item(flattenRecord));

        NestedRecordWithUpdateBehavior updateNestedRecord = new NestedRecordWithUpdateBehavior();
        updateNestedRecord.setNestedCounter(100L);

        CompositeRecord updateCompositeRecord = new CompositeRecord();
        updateCompositeRecord.setNestedRecord(updateNestedRecord);

        FlattenRecord updatedFlattenRecord = new FlattenRecord();
        updatedFlattenRecord.setId("id456");
        updatedFlattenRecord.setCompositeRecord(updateCompositeRecord);

        FlattenRecord persistedFlattenedRecord =
            flattenedMappedTable.updateItem(r -> r.item(updatedFlattenRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        assertThat(persistedFlattenedRecord.getCompositeRecord()).isNotNull();
        verifySingleLevelNestingTargetedUpdateBehavior(persistedFlattenedRecord.getCompositeRecord().getNestedRecord(), 100L,
                                                       TEST_BEHAVIOUR_ATTRIBUTE, INSTANT_1);
    }

    @Test
    public void when_updatingNestedObjectWithMultipleLevelFlattened_existingInformationIsPreserved_scalar_only_update() {
        NestedRecordWithUpdateBehavior outerNestedRecord = createNestedWithDefaults("id123", 10L);
        NestedRecordWithUpdateBehavior innerNestedRecord = createNestedWithDefaults("id456", 5L);
        outerNestedRecord.setNestedRecord(innerNestedRecord);

        CompositeRecord compositeRecord = new CompositeRecord();
        compositeRecord.setNestedRecord(outerNestedRecord);

        FlattenRecord flattenRecord = new FlattenRecord();
        flattenRecord.setCompositeRecord(compositeRecord);
        flattenRecord.setId("id789");

        flattenedMappedTable.putItem(r -> r.item(flattenRecord));

        NestedRecordWithUpdateBehavior updateOuterNestedRecord = new NestedRecordWithUpdateBehavior();
        updateOuterNestedRecord.setNestedCounter(100L);

        NestedRecordWithUpdateBehavior updateInnerNestedRecord = new NestedRecordWithUpdateBehavior();
        updateInnerNestedRecord.setNestedCounter(50L);

        updateOuterNestedRecord.setNestedRecord(updateInnerNestedRecord);

        CompositeRecord updateCompositeRecord = new CompositeRecord();
        updateCompositeRecord.setNestedRecord(updateOuterNestedRecord);

        FlattenRecord updateFlattenRecord = new FlattenRecord();
        updateFlattenRecord.setCompositeRecord(updateCompositeRecord);
        updateFlattenRecord.setId("id789");

        FlattenRecord persistedFlattenedRecord =
            flattenedMappedTable.updateItem(r -> r.item(updateFlattenRecord).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        assertThat(persistedFlattenedRecord.getCompositeRecord()).isNotNull();
        verifyMultipleLevelNestingTargetedUpdateBehavior(persistedFlattenedRecord.getCompositeRecord().getNestedRecord(), 100L,
                                                         50L, TEST_BEHAVIOUR_ATTRIBUTE, INSTANT_1);
        assertThat(persistedFlattenedRecord.getCompositeRecord().getNestedRecord().getNestedCounter()).isEqualTo(100L);
        assertThat(persistedFlattenedRecord.getCompositeRecord().getNestedRecord().getNestedRecord().getNestedCounter()).isEqualTo(50L);
        assertThat(persistedFlattenedRecord.getCompositeRecord().getNestedRecord().getNestedRecord().getNestedCreatedTimeAttribute()).isNotNull();
    }

    /**
     * Currently, nested records are not updated through extensions (only the timestamp).
     */
    @Test
    public void updateBehaviors_nested() {
        NestedRecordWithUpdateBehavior nestedRecord = new NestedRecordWithUpdateBehavior();
        nestedRecord.setId("id456");

        RecordWithUpdateBehaviors record = new RecordWithUpdateBehaviors();
        record.setId("id123");
        record.setCreatedOn(INSTANT_1);
        record.setLastUpdatedOn(INSTANT_2);
        record.setNestedRecord(nestedRecord);
        mappedTable.updateItem(record);

        RecordWithUpdateBehaviors persistedRecord = mappedTable.getItem(record);

        assertThat(persistedRecord.getVersion()).isEqualTo(1L);
        assertThat(persistedRecord.getNestedRecord()).isNotNull();
        assertThat(persistedRecord.getNestedRecord().getNestedVersionedAttribute()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedCounter()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedUpdateBehaviorAttribute()).isNull();
        assertThat(persistedRecord.getNestedRecord().getNestedCreatedTimeAttribute()).isNotNull();
    }

    @Test
    public void updateBehaviour_onItemWithRootAttributeNameContainingReservedMarker_throwsException() {

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'attr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        InvalidRootAttributeBean record = new InvalidRootAttributeBean();
        record.setId("1");
        record.setAttr_NESTED_ATTR_UPDATE_(INSTANT_1);

        beanWithInvalidRootAttrNameMappedTable.updateItem(r -> r.item(record)
                                                                .ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));
    }

    @Test
    public void updateBehaviour_onItemWithNestedAttributeNameContainingReservedMarker_throwsException() {

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'attr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        InvalidNestedAttributeBean record = new InvalidNestedAttributeBean();
        record.setId("1");

        InvalidNestedAttributeChild childBean = new InvalidNestedAttributeChild();
        childBean.setId("2");
        childBean.setAttr_NESTED_ATTR_UPDATE_(INSTANT_1);
        record.setNestedChildAttribute(childBean);

        beanWithInvalidNestedAttrNameMappedTable.updateItem(r -> r.item(record)
                                                                  .ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));
    }
}
