/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, AutoTimestamp 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension.AttributeTags.autoGeneratedTimestampAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedStaticLevel2RecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedStaticLevel3RecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedStaticLevel4Record;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedStaticRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildStaticSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithInvalidAttributeNameOnNestedLevel.RecordWithReservedMarkerNestedChildAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.internal.AttributeValues.stringValue;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.updateBehavior;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.converters.EpochMillisFormatTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.converters.TimeFormatUpdateTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithInvalidAttributeNameOnNestedLevel;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.RecordWithInvalidAttributeNameOnRoot;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.PutItemEnhancedRequest;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;
import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;

public class AutoGeneratedTimestampRecordTest extends LocalDynamoDbSyncTestBase {

    public static final Instant MOCKED_INSTANT_NOW = Instant.now(Clock.fixed(Instant.parse("2019-01-13T14:00:00Z"),
                                                                             ZoneOffset.UTC));

    public static final Instant MOCKED_INSTANT_UPDATE_ONE = Instant.now(Clock.fixed(Instant.parse("2019-01-14T14:00:00Z"),
                                                                                    ZoneOffset.UTC));


    public static final Instant MOCKED_INSTANT_UPDATE_TWO = Instant.now(Clock.fixed(Instant.parse("2019-01-15T14:00:00Z"),
                                                                                    ZoneOffset.UTC));

    private static final TableSchema<FlattenedRecord> FLATTENED_TABLE_SCHEMA =
        StaticTableSchema.builder(FlattenedRecord.class)
                         .newItemSupplier(FlattenedRecord::new)
                         .addAttribute(Instant.class, a -> a.name("generated")
                                                            .getter(FlattenedRecord::getGenerated)
                                                            .setter(FlattenedRecord::setGenerated)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .build();

    private static final TableSchema<Record> TABLE_SCHEMA =
        StaticTableSchema.builder(Record.class)
                         .newItemSupplier(Record::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(Record::getId)
                                                           .setter(Record::setId)
                                                           .tags(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("attribute")
                                                           .getter(Record::getAttribute)
                                                           .setter(Record::setAttribute))
                         .addAttribute(Instant.class, a -> a.name("lastUpdatedDate")
                                                            .getter(Record::getLastUpdatedDate)
                                                            .setter(Record::setLastUpdatedDate)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class, a -> a.name("createdDate")
                                                            .getter(Record::getCreatedDate)
                                                            .setter(Record::setCreatedDate)
                                                            .tags(autoGeneratedTimestampAttribute(),
                                                                  updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                         .addAttribute(Instant.class, a -> a.name("lastUpdatedDateInEpochMillis")
                                                            .getter(Record::getLastUpdatedDateInEpochMillis)
                                                            .setter(Record::setLastUpdatedDateInEpochMillis)
                                                            .attributeConverter(EpochMillisFormatTestConverter.create())
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class, a -> a.name("convertedLastUpdatedDate")
                                                            .getter(Record::getConvertedLastUpdatedDate)
                                                            .setter(Record::setConvertedLastUpdatedDate)
                                                            .attributeConverter(TimeFormatUpdateTestConverter.create())
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .flatten(FLATTENED_TABLE_SCHEMA, Record::getFlattenedRecord, Record::setFlattenedRecord)
                         .addAttribute(EnhancedType.documentOf(NestedStaticRecordWithList.class,
                                                               buildStaticSchemaForNestedRecordWithList(),
                                                               b -> b.ignoreNulls(true)),
                                       a -> a.name("nestedRecord").getter(Record::getNestedRecord)
                                             .setter(Record::setNestedRecord))
                         .build();


    private static final TableSchema<RecursiveRecord> LEVEL3_SCHEMA =
        StaticTableSchema.builder(RecursiveRecord.class)
                         .newItemSupplier(RecursiveRecord::new)
                         .addAttribute(String.class,
                                       a -> a.name("id")
                                             .getter(RecursiveRecord::getId)
                                             .setter(RecursiveRecord::setId)
                                             .tags(primaryPartitionKey()))
                         .addAttribute(String.class,
                                       a -> a.name("name")
                                             .getter(RecursiveRecord::getName)
                                             .setter(RecursiveRecord::setName))
                         .addAttribute(Instant.class,
                                       a -> a.name("grandchildTimestamp1")
                                             .getter(RecursiveRecord::getChildTimestamp1)
                                             .setter(RecursiveRecord::setChildTimestamp1)
                                             .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class,
                                       a -> a.name("grandchildTimestamp2")
                                             .getter(RecursiveRecord::getChildTimestamp2)
                                             .setter(RecursiveRecord::setChildTimestamp2)
                                             .tags(autoGeneratedTimestampAttribute())
                         ).build();

    private static final TableSchema<RecursiveRecord> LEVEL2_SCHEMA =
        StaticTableSchema.builder(RecursiveRecord.class)
                         .newItemSupplier(RecursiveRecord::new)
                         .addAttribute(String.class,
                                       a -> a.name("id")
                                             .getter(RecursiveRecord::getId)
                                             .setter(RecursiveRecord::setId)
                                             .tags(primaryPartitionKey()))
                         .addAttribute(String.class,
                                       a -> a.name("name")
                                             .getter(RecursiveRecord::getName)
                                             .setter(RecursiveRecord::setName))
                         .addAttribute(Instant.class,
                                       a -> a.name("childTimestamp1")
                                             .getter(RecursiveRecord::getChildTimestamp1)
                                             .setter(RecursiveRecord::setChildTimestamp1)
                                             .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class,
                                       a -> a.name("childTimestamp2")
                                             .getter(RecursiveRecord::getChildTimestamp2)
                                             .setter(RecursiveRecord::setChildTimestamp2)
                                             .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(EnhancedType.documentOf(RecursiveRecord.class, LEVEL3_SCHEMA),
                                       a -> a.name("child")
                                             .getter(RecursiveRecord::getChild)
                                             .setter(RecursiveRecord::setChild)
                         ).build();

    private static final TableSchema<RecursiveRecord> LEVEL1_SCHEMA =
        StaticTableSchema.builder(RecursiveRecord.class)
                         .newItemSupplier(RecursiveRecord::new)
                         .addAttribute(String.class,
                                       a -> a.name("id")
                                             .getter(RecursiveRecord::getId)
                                             .setter(RecursiveRecord::setId)
                                             .tags(primaryPartitionKey()))
                         .addAttribute(String.class,
                                       a -> a.name("name")
                                             .getter(RecursiveRecord::getName)
                                             .setter(RecursiveRecord::setName))
                         .addAttribute(Instant.class,
                                       a -> a.name("parentTimestamp")
                                             .getter(RecursiveRecord::getParentTimestamp)
                                             .setter(RecursiveRecord::setParentTimestamp)
                                             .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(EnhancedType.documentOf(RecursiveRecord.class, LEVEL2_SCHEMA),
                                       a -> a.name("child")
                                             .getter(RecursiveRecord::getChild)
                                             .setter(RecursiveRecord::setChild)
                         ).build();


    private final DynamoDbTable<Record> mappedTable;

    private final Clock mockCLock = Mockito.mock(Clock.class);


    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(AutoGeneratedTimestampRecordExtension.builder().baseClock(mockCLock).build())
                              .build();
    private final String concreteTableName;

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    {
        concreteTableName = getConcreteTableName("table-name");
        mappedTable = enhancedClient.table(concreteTableName, TABLE_SCHEMA);
    }

    public static Record createUniqueFakeItem() {
        Record record = new Record();
        record.setId(UUID.randomUUID().toString());
        return record;
    }

    @Before
    public void createTable() {
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_NOW);
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(DeleteTableRequest.builder()
                                                          .tableName(getConcreteTableName("table-name"))
                                                          .build());
    }

    @Test
    public void putNewRecord_setsInitialTimestamps_onAllNestedBeanLevels() {
        NestedStaticLevel4Record nestedLevel4 = new NestedStaticLevel4Record().setAttr("attrL4");
        NestedStaticLevel3RecordWithList nestedLevel3 =
            new NestedStaticLevel3RecordWithList().setAttr("attrL3").setLevel4(nestedLevel4);
        NestedStaticLevel2RecordWithList level2 =
            new NestedStaticLevel2RecordWithList().setAttr("attrL2").setLevel3(nestedLevel3);
        NestedStaticRecordWithList nestedLevel1 = new NestedStaticRecordWithList().setAttr("attrL1").setLevel2(level2);

        Record item = new Record()
            .setId("id")
            .setAttribute("one")
            .setNestedRecord(nestedLevel1);

        mappedTable.putItem(r -> r.item(item));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse stored = getItemAsStoredFromDDB();

        NestedStaticLevel4Record expL4 = new NestedStaticLevel4Record()
            .setTime(MOCKED_INSTANT_NOW).setAttr("attrL4");
        NestedStaticLevel3RecordWithList expL3 = new NestedStaticLevel3RecordWithList()
            .setTime(MOCKED_INSTANT_NOW).setAttr("attrL3").setLevel4(expL4);
        NestedStaticLevel2RecordWithList expL2 = new NestedStaticLevel2RecordWithList()
            .setTime(MOCKED_INSTANT_NOW).setAttr("attrL2").setLevel3(expL3);
        NestedStaticRecordWithList expL1 = new NestedStaticRecordWithList()
            .setTime(MOCKED_INSTANT_NOW).setAttr("attrL1").setLevel2(expL2);

        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);

        Record expectedRecord = new Record()
            .setId("id")
            .setAttribute("one")
            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setCreatedDate(MOCKED_INSTANT_NOW)
            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
            .setFlattenedRecord(flattenedRecord)
            .setNestedRecord(expL1);

        assertThat(result, is(expectedRecord));
        assertThat(stored.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        // nestedLevel1 assertions
        Map<String, AttributeValue> lvl1Map = stored.item().get("nestedRecord").m();
        assertThat(lvl1Map.get("time").s(), is(MOCKED_INSTANT_NOW.toString()));

        // level2 assertions
        Map<String, AttributeValue> lvl2Map = lvl1Map.get("level2").m();
        assertThat(lvl2Map.get("time").s(), is(MOCKED_INSTANT_NOW.toString()));

        // level3 assertions
        Map<String, AttributeValue> lvl3Map = lvl2Map.get("level3").m();
        assertThat(lvl3Map.get("time").s(), is(MOCKED_INSTANT_NOW.toString()));

        // level4 assertions
        Map<String, AttributeValue> lvl4Map = lvl3Map.get("level4").m();
        assertThat(lvl4Map.get("time").s(), is(MOCKED_INSTANT_NOW.toString()));
    }

    @Test
    public void updateNewRecordSetsAutoFormattedDate() {
        Record result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                                       .setNestedRecord(new NestedStaticRecordWithList()
                                                                                            .setAttr("attribute"))));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        NestedStaticRecordWithList expectednestedLevel1 = new NestedStaticRecordWithList().setTime(MOCKED_INSTANT_NOW)
                                                                                          .setAttr("attribute");
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord)
                                            .setNestedRecord(expectednestedLevel1);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_NOW.toString()));
    }

    @Test
    public void putExistingRecordUpdatedWithAutoFormattedTimestamps() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     // Note : Since we are doing PutItem second time, the createDate gets updated,
                                     .setCreatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);

        System.out.println("result " + result);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("14 01 2019 14:00:00"));
    }

    @Test
    public void putItemFollowedByUpdates() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setCreatedDate(MOCKED_INSTANT_NOW)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("14 01 2019 14:00:00"));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_TWO);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_TWO)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_TWO)
                                     .setCreatedDate(MOCKED_INSTANT_NOW)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_TWO)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("15 01 2019 14:00:00"));

        System.out.println(Instant.ofEpochMilli(Long.parseLong(itemAsStoredInDDB.item().get("lastUpdatedDateInEpochMillis").n())));
        assertThat(Long.parseLong(itemAsStoredInDDB.item().get("lastUpdatedDateInEpochMillis").n()),
                   is(MOCKED_INSTANT_UPDATE_TWO.toEpochMilli()));
    }

    @Test
    public void putExistingRecordWithConditionExpressions() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                  .item(new Record().setId("id").setAttribute("one"))
                                                  .conditionExpression(conditionExpression)
                                                  .build());

        result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     //  Note that this is a second putItem call so create date is updated.
                                     .setCreatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
    }

    @Test
    public void updateExistingRecordWithConditionExpressions() {
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));
        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one"))
                                     .conditionExpression(conditionExpression));

        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
    }

    @Test
    public void putItemConditionTestFailure() {

        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        thrown.expect(ConditionalCheckFailedException.class);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                  .item(new Record().setId("id").setAttribute("one"))
                                                  .conditionExpression(conditionExpression)
                                                  .build());

    }

    @Test
    public void updateItemConditionTestFailure() {
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();
        thrown.expect(ConditionalCheckFailedException.class);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                  .item(new Record().setId("id").setAttribute("one"))
                                                  .conditionExpression(conditionExpression)
                                                  .build());
    }

    @Test
    public void autogenerateTimestamps_onItemWithNonInstantAttributeName_throwsException() {

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute 'lastUpdatedDate' of Class type class java.lang.String is not a suitable "
                             + "Java Class type to be used as a Auto Generated Timestamp attribute. Only java.time."
                             + "Instant Class type is supported.");
        StaticTableSchema.builder(RecordWithStringUpdateDate.class)
                         .newItemSupplier(RecordWithStringUpdateDate::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(RecordWithStringUpdateDate::getId)
                                                           .setter(RecordWithStringUpdateDate::setId)
                                                           .tags(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("lastUpdatedDate")
                                                           .getter(RecordWithStringUpdateDate::getLastUpdatedDate)
                                                           .setter(RecordWithStringUpdateDate::setLastUpdatedDate)
                                                           .tags(autoGeneratedTimestampAttribute()))
                         .build();
    }

    @Test
    public void autogenerateTimestamps_onItemWithRootAttributeNameContainingReservedMarker_throwsException() {

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'attr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        StaticTableSchema
            .builder(RecordWithInvalidAttributeNameOnRoot.class)
            .newItemSupplier(RecordWithInvalidAttributeNameOnRoot::new)
            .addAttribute(String.class,
                          a -> a.name("id")
                                .getter(RecordWithInvalidAttributeNameOnRoot::getId)
                                .setter(RecordWithInvalidAttributeNameOnRoot::setId)
                                .tags(primaryPartitionKey()))

            .addAttribute(Instant.class,
                          a -> a.name("attr_NESTED_ATTR_UPDATE_")
                                .getter(RecordWithInvalidAttributeNameOnRoot::getAttr_NESTED_ATTR_UPDATE_)
                                .setter(RecordWithInvalidAttributeNameOnRoot::setAttr_NESTED_ATTR_UPDATE_)
                                .tags(autoGeneratedTimestampAttribute()))
            .build();
    }

    @Test
    public void autogenerateTimestamps_onItemWithNestedAttributeNameContainingReservedMarker_throwsException() {

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute name 'childAttr_NESTED_ATTR_UPDATE_' contains reserved marker "
                             + "'_NESTED_ATTR_UPDATE_' and is not allowed.");

        StaticTableSchema
            .builder(RecordWithInvalidAttributeNameOnNestedLevel.class)
            .newItemSupplier(RecordWithInvalidAttributeNameOnNestedLevel::new)
            .addAttribute(
                String.class,
                a -> a.name("id")
                      .getter(RecordWithInvalidAttributeNameOnNestedLevel::getId)
                      .setter(RecordWithInvalidAttributeNameOnNestedLevel::setId)
                      .tags(primaryPartitionKey()))

            .addAttribute(
                EnhancedType.documentOf(
                    RecordWithReservedMarkerNestedChildAttribute.class,
                    StaticTableSchema
                        .builder(RecordWithReservedMarkerNestedChildAttribute.class)
                        .newItemSupplier(RecordWithReservedMarkerNestedChildAttribute::new)
                        .addAttribute(Instant.class,
                                      a -> a.name("childAttr_NESTED_ATTR_UPDATE_")
                                            .getter(RecordWithReservedMarkerNestedChildAttribute::getAttr_NESTED_ATTR_UPDATE_)
                                            .setter(RecordWithReservedMarkerNestedChildAttribute::setAttr_NESTED_ATTR_UPDATE_)
                                            .tags(autoGeneratedTimestampAttribute()))
                        .build()),

                a -> a.name("nestedChildAttribute")
                      .getter(RecordWithInvalidAttributeNameOnNestedLevel::getNestedChildAttribute)
                      .setter(RecordWithInvalidAttributeNameOnNestedLevel::setNestedChildAttribute))
            .build();
    }

    @Test
    public void putItemFollowedByUpdatesShouldGenerateTimestampsOnNestedFields() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                    .setNestedRecord(new NestedStaticRecordWithList().setAttr("attribute"))));
        mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_NOW.toString()));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedStaticRecordWithList().setAttr(
                                                           "attribute1"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute1"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_UPDATE_ONE.toString()));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedStaticRecordWithList().setAttr(
                                                           "attribute2"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute2"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_UPDATE_TWO.toString()));
    }

    @Test
    public void putItemFollowedByUpdatesShouldGenerateTimestampsOnNestedFieldsList() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                    .setNestedRecord(new NestedStaticRecordWithList().setAttr("attribute"))));
        mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_NOW.toString()));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedStaticRecordWithList().setAttr(
                                                           "attribute1"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute1"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_UPDATE_ONE.toString()));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedStaticRecordWithList().setAttr(
                                                           "attribute2"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("attr").s(), is("attribute2"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("time").s(),
                   is(MOCKED_INSTANT_UPDATE_TWO.toString()));
    }

    @Test
    public void recursiveRecord_schemasWithSameTypeButDifferentAttributes_allTimestampsAreUpdated() {
        RecursiveRecord level3 = new RecursiveRecord()
            .setId("l3_id")
            .setName("l3_name");

        RecursiveRecord level2 = new RecursiveRecord()
            .setId("l2_id")
            .setName("l2_name")
            .setChild(level3);

        RecursiveRecord level1 = new RecursiveRecord()
            .setId("l1_id")
            .setName("l1_name")
            .setChild(level2);

        String tableName = getConcreteTableName("recursive-record-table-all-timestamps");
        DynamoDbTable<RecursiveRecord> parentTable = enhancedClient.table(tableName, LEVEL1_SCHEMA);
        parentTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_NOW);

        parentTable.putItem(level1);

        Map<String, AttributeValue> key = new HashMap<>();
        key.put("id", AttributeValue.builder().s("l1_id").build());
        GetItemResponse response = getDynamoDbClient().getItem(GetItemRequest.builder()
                                                                             .tableName(tableName)
                                                                             .key(key)
                                                                             .consistentRead(true)
                                                                             .build());
        Map<String, AttributeValue> item = response.item();

        // Assert parent timestamp is set
        assertNotNull(item.get("parentTimestamp"));
        assertEquals(MOCKED_INSTANT_NOW.toString(), item.get("parentTimestamp").s());

        Map<String, AttributeValue> childMap = item.get("child").m();
        RecursiveRecord deserializedChild = LEVEL2_SCHEMA.mapToItem(childMap);
        assertNotNull(deserializedChild);
        // Assert child timestamps are set
        assertEquals(MOCKED_INSTANT_NOW, deserializedChild.getChildTimestamp1());
        assertEquals(MOCKED_INSTANT_NOW, deserializedChild.getChildTimestamp2());

        Map<String, AttributeValue> grandchildMap = item.get("child").m();
        RecursiveRecord deserializedGrandchild = LEVEL2_SCHEMA.mapToItem(grandchildMap);
        assertNotNull(deserializedGrandchild);
        // Assert grandchild timestamps are set
        assertEquals(MOCKED_INSTANT_NOW, deserializedGrandchild.getChildTimestamp1());
        assertEquals(MOCKED_INSTANT_NOW, deserializedGrandchild.getChildTimestamp2());
    }

    private GetItemResponse getItemAsStoredFromDDB() {
        Map<String, AttributeValue> key = new HashMap<>();
        key.put("id", AttributeValue.builder().s("id").build());
        return getDynamoDbClient().getItem(GetItemRequest
                                               .builder().tableName(concreteTableName)
                                               .key(key)
                                               .consistentRead(true).build());
    }

    private static class FlattenedRecord {
        private Instant generated;

        public Instant getGenerated() {
            return generated;
        }

        public FlattenedRecord setGenerated(Instant generated) {
            this.generated = generated;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            FlattenedRecord that = (FlattenedRecord) o;
            return Objects.equals(generated, that.generated);
        }

        @Override
        public int hashCode() {
            return Objects.hash(generated);
        }

        @Override
        public String toString() {
            return "FlattenedRecord{" +
                   "generated=" + generated +
                   '}';
        }
    }

    private static class Record {
        private String id;
        private String attribute;
        private Instant createdDate;
        private Instant lastUpdatedDate;
        private Instant convertedLastUpdatedDate;
        private Instant lastUpdatedDateInEpochMillis;
        private FlattenedRecord flattenedRecord;
        private NestedStaticRecordWithList nestedLevel1;

        private String getId() {
            return id;
        }

        private Record setId(String id) {
            this.id = id;
            return this;
        }

        private String getAttribute() {
            return attribute;
        }

        private Record setAttribute(String attribute) {
            this.attribute = attribute;
            return this;
        }

        private Instant getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        private Record setLastUpdatedDate(Instant lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        private Instant getCreatedDate() {
            return createdDate;
        }

        private Record setCreatedDate(Instant createdDate) {
            this.createdDate = createdDate;
            return this;
        }

        private Instant getConvertedLastUpdatedDate() {
            return convertedLastUpdatedDate;
        }

        private Record setConvertedLastUpdatedDate(Instant convertedLastUpdatedDate) {
            this.convertedLastUpdatedDate = convertedLastUpdatedDate;
            return this;
        }

        private Instant getLastUpdatedDateInEpochMillis() {
            return lastUpdatedDateInEpochMillis;
        }

        private Record setLastUpdatedDateInEpochMillis(Instant lastUpdatedDateInEpochMillis) {
            this.lastUpdatedDateInEpochMillis = lastUpdatedDateInEpochMillis;
            return this;
        }

        public FlattenedRecord getFlattenedRecord() {
            return flattenedRecord;
        }

        public Record setFlattenedRecord(FlattenedRecord flattenedRecord) {
            this.flattenedRecord = flattenedRecord;
            return this;
        }

        public NestedStaticRecordWithList getNestedRecord() {
            return nestedLevel1;
        }

        public Record setNestedRecord(NestedStaticRecordWithList nestedLevel1) {
            this.nestedLevel1 = nestedLevel1;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            Record record = (Record) o;
            return Objects.equals(id, record.id) &&
                   Objects.equals(attribute, record.attribute) &&
                   Objects.equals(lastUpdatedDate, record.lastUpdatedDate) &&
                   Objects.equals(createdDate, record.createdDate) &&
                   Objects.equals(lastUpdatedDateInEpochMillis, record.lastUpdatedDateInEpochMillis) &&
                   Objects.equals(convertedLastUpdatedDate, record.convertedLastUpdatedDate) &&
                   Objects.equals(flattenedRecord, record.flattenedRecord) &&
                   Objects.equals(nestedLevel1, record.nestedLevel1);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, attribute, lastUpdatedDate, createdDate, lastUpdatedDateInEpochMillis,
                                convertedLastUpdatedDate, flattenedRecord, nestedLevel1);
        }

        @Override
        public String toString() {
            return "Record{" +
                   "id='" + id + '\'' +
                   ", attribute='" + attribute + '\'' +
                   ", createdDate=" + createdDate +
                   ", lastUpdatedDate=" + lastUpdatedDate +
                   ", convertedLastUpdatedDate=" + convertedLastUpdatedDate +
                   ", lastUpdatedDateInEpochMillis=" + lastUpdatedDateInEpochMillis +
                   ", flattenedRecord=" + flattenedRecord +
                   ", nestedRecord=" + nestedLevel1 +
                   '}';
        }
    }

    private static class RecordWithStringUpdateDate {
        private String id;
        private String lastUpdatedDate;


        private String getId() {
            return id;
        }

        private RecordWithStringUpdateDate setId(String id) {
            this.id = id;
            return this;
        }


        private String getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        private RecordWithStringUpdateDate setLastUpdatedDate(String lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            RecordWithStringUpdateDate record = (RecordWithStringUpdateDate) o;
            return Objects.equals(id, record.id) &&
                   Objects.equals(lastUpdatedDate, record.lastUpdatedDate);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, lastUpdatedDate);
        }

        @Override
        public String toString() {
            return "RecordWithStringUpdateDate{" +
                   "id='" + id + '\'' +
                   ", lastUpdatedDate=" + lastUpdatedDate +
                   '}';
        }
    }

    public static class RecursiveRecord {
        private String id;
        private String name;
        private Instant parentTimestamp;
        private Instant childTimestamp1;
        private Instant childTimestamp2;
        private RecursiveRecord child;

        public String getId() {
            return id;
        }

        public RecursiveRecord setId(String id) {
            this.id = id;
            return this;
        }

        public String getName() {
            return name;
        }

        public RecursiveRecord setName(String name) {
            this.name = name;
            return this;
        }

        public Instant getParentTimestamp() {
            return parentTimestamp;
        }

        public RecursiveRecord setParentTimestamp(Instant parentTimestamp) {
            this.parentTimestamp = parentTimestamp;
            return this;
        }

        public Instant getChildTimestamp1() {
            return childTimestamp1;
        }

        public RecursiveRecord setChildTimestamp1(Instant childTimestamp1) {
            this.childTimestamp1 = childTimestamp1;
            return this;
        }

        public Instant getChildTimestamp2() {
            return childTimestamp2;
        }

        public RecursiveRecord setChildTimestamp2(Instant childTimestamp2) {
            this.childTimestamp2 = childTimestamp2;
            return this;
        }

        public RecursiveRecord getChild() {
            return child;
        }

        public RecursiveRecord setChild(RecursiveRecord child) {
            this.child = child;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            RecursiveRecord that = (RecursiveRecord) o;
            return Objects.equals(id, that.id) &&
                   Objects.equals(name, that.name) &&
                   Objects.equals(parentTimestamp, that.parentTimestamp) &&
                   Objects.equals(childTimestamp1, that.childTimestamp1) &&
                   Objects.equals(childTimestamp2, that.childTimestamp2) &&
                   Objects.equals(child, that.child);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, name, parentTimestamp, childTimestamp1, childTimestamp2, child);
        }

        @Override
        public String toString() {
            return "RecursiveRecord{" +
                   "id='" + id + '\'' +
                   ", name='" + name + '\'' +
                   ", parentTimestamp=" + parentTimestamp +
                   ", childTimestamp1=" + childTimestamp1 +
                   ", childTimestamp2=" + childTimestamp2 +
                   ", child=" + child +
                   '}';
        }
    }
}
