/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, AutoTimestamp 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension.AttributeTags.autoGeneratedTimestampAttribute;
import static software.amazon.awssdk.enhanced.dynamodb.internal.AttributeValues.stringValue;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.primaryPartitionKey;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTags.updateBehavior;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;
import software.amazon.awssdk.enhanced.dynamodb.Expression;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.converters.EpochMillisFormatTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.converters.TimeFormatUpdateTestConverter;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.PutItemEnhancedRequest;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException;
import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;

public class AutoGeneratedTimestampRecordTest extends LocalDynamoDbSyncTestBase {

    public static final Instant MOCKED_INSTANT_NOW = Instant.now(Clock.fixed(Instant.parse("2019-01-13T14:00:00Z"),
                                                                             ZoneOffset.UTC));

    public static final Instant MOCKED_INSTANT_UPDATE_ONE = Instant.now(Clock.fixed(Instant.parse("2019-01-14T14:00:00Z"),
                                                                                    ZoneOffset.UTC));

    public static final Instant MOCKED_INSTANT_UPDATE_TWO = Instant.now(Clock.fixed(Instant.parse("2019-01-15T14:00:00Z"),
                                                                                    ZoneOffset.UTC));

    private static final TableSchema<FlattenedRecord> FLATTENED_TABLE_SCHEMA =
        StaticTableSchema.builder(FlattenedRecord.class)
                         .newItemSupplier(FlattenedRecord::new)
                         .addAttribute(Instant.class, a -> a.name("generated")
                                                           .getter(FlattenedRecord::getGenerated)
                                                           .setter(FlattenedRecord::setGenerated)
                                                           .tags(autoGeneratedTimestampAttribute()))
                         .build();

    private static final TableSchema<NestedLevel4> nestedLevel4_SCHEMA =
        StaticTableSchema.builder(NestedLevel4.class)
                         .newItemSupplier(NestedLevel4::new)
                         .addAttribute(Instant.class, a -> a.name("nestedLevel4TimeAttribute")
                                                            .getter(NestedLevel4::getNestedLevel4TimeAttribute)
                                                            .setter(NestedLevel4::setNestedLevel4TimeAttribute)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(String.class, a -> a.name("nestedLevel4Attribute")
                                                           .getter(NestedLevel4::getNestedLevel4Attribute)
                                                           .setter(NestedLevel4::setNestedLevel4Attribute))
                         .build();

    private static final TableSchema<NestedLevel3> nestedLevel3_SCHEMA =
        StaticTableSchema.builder(NestedLevel3.class)
                         .newItemSupplier(NestedLevel3::new)
                         .addAttribute(Instant.class, a -> a.name("nestedLevel3TimeAttribute")
                                                            .getter(NestedLevel3::getNestedLevel3TimeAttribute)
                                                            .setter(NestedLevel3::setNestedLevel3TimeAttribute)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(String.class, a -> a.name("nestedLevel3Attribute")
                                                           .getter(NestedLevel3::getNestedLevel3Attribute)
                                                           .setter(NestedLevel3::setNestedLevel3Attribute))
                         .addAttribute(
                             EnhancedType.documentOf(NestedLevel4.class, nestedLevel4_SCHEMA),
                             a -> a.name("nestedLevel4")
                                   .getter(NestedLevel3::getNestedLevel4)
                                   .setter(NestedLevel3::setNestedLevel4))
                         .build();

    private static final TableSchema<NestedLevel2> nestedLevel2_SCHEMA =
        StaticTableSchema.builder(NestedLevel2.class)
                         .newItemSupplier(NestedLevel2::new)
                         .addAttribute(Instant.class, a -> a.name("nestedLevel2TimeAttribute")
                                                            .getter(NestedLevel2::getNestedLevel2TimeAttribute)
                                                            .setter(NestedLevel2::setNestedLevel2TimeAttribute)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(String.class, a -> a.name("nestedLevel2Attribute")
                                                           .getter(NestedLevel2::getNestedLevel2Attribute)
                                                           .setter(NestedLevel2::setNestedLevel2Attribute))
                         .addAttribute(
                             EnhancedType.documentOf(NestedLevel3.class, nestedLevel3_SCHEMA),
                             a -> a.name("nestedLevel3")
                                   .getter(NestedLevel2::getNestedLevel3)
                                   .setter(NestedLevel2::setNestedLevel3))
                         .build();

    private static final TableSchema<NestedLevel1> nestedLevel1_SCHEMA =
        StaticTableSchema.builder(NestedLevel1.class)
                         .newItemSupplier(NestedLevel1::new)
                         .addAttribute(Instant.class, a -> a.name("nestedLevel1TimeAttribute")
                                                            .getter(NestedLevel1::getNestedLevel1TimeAttribute)
                                                            .setter(NestedLevel1::setNestedLevel1TimeAttribute)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(String.class, a -> a.name("nestedLevel1Attribute")
                                                           .getter(NestedLevel1::getNestedLevel1Attribute)
                                                           .setter(NestedLevel1::setNestedLevel1Attribute))
                         .addAttribute(
                             EnhancedType.documentOf(NestedLevel2.class, nestedLevel2_SCHEMA),
                             a -> a.name("nestedLevel2")
                                   .getter(NestedLevel1::getNestedLevel2)
                                   .setter(NestedLevel1::setNestedLevel2))
                         .build();

    private static final TableSchema<Record> TABLE_SCHEMA =
        StaticTableSchema.builder(Record.class)
                         .newItemSupplier(Record::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(Record::getId)
                                                           .setter(Record::setId)
                                                           .tags(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("attribute")
                                                           .getter(Record::getAttribute)
                                                           .setter(Record::setAttribute))
                         .addAttribute(Instant.class, a -> a.name("lastUpdatedDate")
                                                            .getter(Record::getLastUpdatedDate)
                                                            .setter(Record::setLastUpdatedDate)
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class, a -> a.name("createdDate")
                                                            .getter(Record::getCreatedDate)
                                                            .setter(Record::setCreatedDate)
                                                            .tags(autoGeneratedTimestampAttribute(),
                                                                  updateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)))
                         .addAttribute(Instant.class, a -> a.name("lastUpdatedDateInEpochMillis")
                                                            .getter(Record::getLastUpdatedDateInEpochMillis)
                                                            .setter(Record::setLastUpdatedDateInEpochMillis)
                                                            .attributeConverter(EpochMillisFormatTestConverter.create())
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .addAttribute(Instant.class, a -> a.name("convertedLastUpdatedDate")
                                                            .getter(Record::getConvertedLastUpdatedDate)
                                                            .setter(Record::setConvertedLastUpdatedDate)
                                                            .attributeConverter(TimeFormatUpdateTestConverter.create())
                                                            .tags(autoGeneratedTimestampAttribute()))
                         .flatten(FLATTENED_TABLE_SCHEMA, Record::getFlattenedRecord, Record::setFlattenedRecord)
                         .addAttribute(EnhancedType.documentOf(NestedLevel1.class,
                                                               nestedLevel1_SCHEMA,
                                                               b -> b.ignoreNulls(true)),
                                       a -> a.name("nestedRecord").getter(Record::getNestedRecord)
                                             .setter(Record::setNestedRecord))
                         .build();

    private final DynamoDbTable<Record> mappedTable;

    private final Clock mockCLock = Mockito.mock(Clock.class);


    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(AutoGeneratedTimestampRecordExtension.builder().baseClock(mockCLock).build())
                              .build();
    private final String concreteTableName;

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    {
        concreteTableName = getConcreteTableName("table-name");
        mappedTable = enhancedClient.table(concreteTableName, TABLE_SCHEMA);
    }

    public static Record createUniqueFakeItem() {
        Record record = new Record();
        record.setId(UUID.randomUUID().toString());
        return record;
    }

    @Before
    public void createTable() {
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_NOW);
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(DeleteTableRequest.builder()
                                                          .tableName(getConcreteTableName("table-name"))
                                                          .build());
    }

    @Test
    public void putNewRecord_setsInitialTimestamps_onAllNestedLevels() {
        NestedLevel4 nestedLevel4 = new NestedLevel4().setNestedLevel4Attribute("attrL4");
        NestedLevel3 nestedLevel3 = new NestedLevel3().setNestedLevel3Attribute("attrL3").setNestedLevel4(nestedLevel4);
        NestedLevel2 nestedLevel2 = new NestedLevel2().setNestedLevel2Attribute("attrL2").setNestedLevel3(nestedLevel3);
        NestedLevel1 nestedLevel1 = new NestedLevel1().setNestedLevel1Attribute("attrL1").setNestedLevel2(nestedLevel2);

        Record item = new Record()
            .setId("id")
            .setAttribute("one")
            .setNestedRecord(nestedLevel1);

        mappedTable.putItem(r -> r.item(item));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse stored = getItemAsStoredFromDDB();

        NestedLevel4 expL4 = new NestedLevel4()
            .setNestedLevel4TimeAttribute(MOCKED_INSTANT_NOW).setNestedLevel4Attribute("attrL4");
        NestedLevel3 expL3 = new NestedLevel3()
            .setNestedLevel3TimeAttribute(MOCKED_INSTANT_NOW).setNestedLevel3Attribute("attrL3").setNestedLevel4(expL4);
        NestedLevel2 expL2 = new NestedLevel2()
            .setNestedLevel2TimeAttribute(MOCKED_INSTANT_NOW).setNestedLevel2Attribute("attrL2").setNestedLevel3(expL3);
        NestedLevel1 expL1 = new NestedLevel1()
            .setNestedLevel1TimeAttribute(MOCKED_INSTANT_NOW).setNestedLevel1Attribute("attrL1").setNestedLevel2(expL2);

        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);

        Record expectedRecord = new Record()
            .setId("id")
            .setAttribute("one")
            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
            .setCreatedDate(MOCKED_INSTANT_NOW)
            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
            .setFlattenedRecord(flattenedRecord)
            .setNestedRecord(expL1);

        assertThat(result, is(expectedRecord));
        assertThat(stored.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        // nestedLevel1 assertions
        Map<String, AttributeValue> lvl1Map = stored.item().get("nestedRecord").m();
        assertThat(lvl1Map.get("nestedLevel1TimeAttribute").s(), is(MOCKED_INSTANT_NOW.toString()));

        // nestedLevel2 assertions
        Map<String, AttributeValue> lvl2Map = lvl1Map.get("nestedLevel2").m();
        assertThat(lvl2Map.get("nestedLevel2TimeAttribute").s(), is(MOCKED_INSTANT_NOW.toString()));

        // nestedLevel3 assertions
        Map<String, AttributeValue> lvl3Map = lvl2Map.get("nestedLevel3").m();
        assertThat(lvl3Map.get("nestedLevel3TimeAttribute").s(), is(MOCKED_INSTANT_NOW.toString()));

        // nestedLevel4 assertions
        Map<String, AttributeValue> lvl4Map = lvl3Map.get("nestedLevel4").m();
        assertThat(lvl4Map.get("nestedLevel4TimeAttribute").s(), is(MOCKED_INSTANT_NOW.toString()));
    }

    @Test
    public void updateNewRecordSetsAutoFormattedDate() {
        Record result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                                       .setNestedRecord(new NestedLevel1()
                                                                                            .setNestedLevel1Attribute("attribute"))));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        NestedLevel1 expectednestedLevel1 = new NestedLevel1().setNestedLevel1TimeAttribute(MOCKED_INSTANT_NOW)
                                            .setNestedLevel1Attribute("attribute");
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord)
                                            .setNestedRecord(expectednestedLevel1);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_NOW.toString()));
    }

    @Test
    public void putExistingRecordUpdatedWithAutoFormattedTimestamps() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     // Note : Since we are doing PutItem second time, the createDate gets updated,
                                     .setCreatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);

        System.out.println("result "+result);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("14 01 2019 14:00:00"));
    }

    @Test
    public void putItemFollowedByUpdates() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("14 01 2019 14:00:00"));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        result = mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        itemAsStoredInDDB = getItemAsStoredFromDDB();
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_TWO);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_TWO)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_TWO)
                                     .setCreatedDate(MOCKED_INSTANT_NOW)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_TWO)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("15 01 2019 14:00:00"));

        System.out.println(Instant.ofEpochMilli(Long.parseLong(itemAsStoredInDDB.item().get("lastUpdatedDateInEpochMillis").n())));
        assertThat(Long.parseLong(itemAsStoredInDDB.item().get("lastUpdatedDateInEpochMillis").n()),
                   is(MOCKED_INSTANT_UPDATE_TWO.toEpochMilli()));
    }

    @Test
    public void putExistingRecordWithConditionExpressions() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_NOW);
        Record expectedRecord = new Record().setId("id")
                                            .setAttribute("one")
                                            .setLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setConvertedLastUpdatedDate(MOCKED_INSTANT_NOW)
                                            .setCreatedDate(MOCKED_INSTANT_NOW)
                                            .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_NOW)
                                            .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                  .item(new Record().setId("id").setAttribute("one"))
                                                  .conditionExpression(conditionExpression)
                                                  .build());

        result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     //  Note that this is a second putItem call so create date is updated.
                                     .setCreatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
    }

    @Test
    public void updateExistingRecordWithConditionExpressions() {
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();
        // The data in DDB is stored in converted time format
        assertThat(itemAsStoredInDDB.item().get("convertedLastUpdatedDate").s(), is("13 01 2019 14:00:00"));
        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("one"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one"))
                                     .conditionExpression(conditionExpression));

        Record result = mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        FlattenedRecord flattenedRecord = new FlattenedRecord().setGenerated(MOCKED_INSTANT_UPDATE_ONE);
        Record expectedRecord = new Record().setId("id")
                                     .setAttribute("one")
                                     .setLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setConvertedLastUpdatedDate(MOCKED_INSTANT_UPDATE_ONE)
                                     .setCreatedDate(MOCKED_INSTANT_NOW)
                                     .setLastUpdatedDateInEpochMillis(MOCKED_INSTANT_UPDATE_ONE)
                                     .setFlattenedRecord(flattenedRecord);
        assertThat(result, is(expectedRecord));
    }

    @Test
    public void putItemConditionTestFailure() {

        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")));

        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();

        thrown.expect(ConditionalCheckFailedException.class);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                                      .item(new Record().setId("id").setAttribute("one"))
                                                                      .conditionExpression(conditionExpression)
                                                                      .build());

    }

    @Test
    public void updateItemConditionTestFailure() {
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")));
        Expression conditionExpression = Expression.builder()
                                                   .expression("#k = :v OR #k = :v1")
                                                   .putExpressionName("#k", "attribute")
                                                   .putExpressionValue(":v", stringValue("wrong1"))
                                                   .putExpressionValue(":v1", stringValue("wrong2"))
                                                   .build();
        thrown.expect(ConditionalCheckFailedException.class);
        mappedTable.putItem(PutItemEnhancedRequest.builder(Record.class)
                                                  .item(new Record().setId("id").setAttribute("one"))
                                                  .conditionExpression(conditionExpression)
                                                  .build());
    }

    @Test
    public void incorrectTypeForAutoUpdateTimestampThrowsException(){

        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("Attribute 'lastUpdatedDate' of Class type class java.lang.String is not a suitable "
                             + "Java Class type to be used as a Auto Generated Timestamp attribute. Only java.time."
                             + "Instant Class type is supported.");
        StaticTableSchema.builder(RecordWithStringUpdateDate.class)
                         .newItemSupplier(RecordWithStringUpdateDate::new)
                         .addAttribute(String.class, a -> a.name("id")
                                                           .getter(RecordWithStringUpdateDate::getId)
                                                           .setter(RecordWithStringUpdateDate::setId)
                                                           .tags(primaryPartitionKey()))
                         .addAttribute(String.class, a -> a.name("lastUpdatedDate")
                                                           .getter(RecordWithStringUpdateDate::getLastUpdatedDate)
                                                           .setter(RecordWithStringUpdateDate::setLastUpdatedDate)
                                                           .tags(autoGeneratedTimestampAttribute()))
                         .build();
    }

    @Test
    public void putItemFollowedByUpdatesShouldGenerateTimestampsOnNestedFields() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                    .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute("attribute"))));
        mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_NOW.toString()));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute(
                                                           "attribute1"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute1"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_UPDATE_ONE.toString()));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute(
                                                           "attribute2"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute2"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_UPDATE_TWO.toString()));
    }

    @Test
    public void putItemFollowedByUpdatesShouldGenerateTimestampsOnNestedFieldsList() {
        mappedTable.putItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                    .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute("attribute"))));
        mappedTable.getItem(r -> r.key(k -> k.partitionValue("id")));
        GetItemResponse itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_NOW.toString()));

        //First Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_ONE);

        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute(
                                                           "attribute1"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute1"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_UPDATE_ONE.toString()));

        //Second Update
        Mockito.when(mockCLock.instant()).thenReturn(MOCKED_INSTANT_UPDATE_TWO);
        mappedTable.updateItem(r -> r.item(new Record().setId("id").setAttribute("one")
                                                       .setNestedRecord(new NestedLevel1().setNestedLevel1Attribute(
                                                           "attribute2"))));
        itemAsStoredInDDB = getItemAsStoredFromDDB();

        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1Attribute").s(), is("attribute2"));
        assertThat(itemAsStoredInDDB.item().get("nestedRecord").m().get("nestedLevel1TimeAttribute").s(),
                   is(MOCKED_INSTANT_UPDATE_TWO.toString()));
    }

    private GetItemResponse getItemAsStoredFromDDB() {
        Map<String, AttributeValue> key = new HashMap<>();
        key.put("id", AttributeValue.builder().s("id").build());
        return getDynamoDbClient().getItem(GetItemRequest
                                               .builder().tableName(concreteTableName)
                                               .key(key)
                                               .consistentRead(true).build());
    }

    private static class FlattenedRecord {
        private Instant generated;

        public Instant getGenerated() {
            return generated;
        }

        public FlattenedRecord setGenerated(Instant generated) {
            this.generated = generated;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            FlattenedRecord that = (FlattenedRecord) o;
            return Objects.equals(generated, that.generated);
        }

        @Override
        public int hashCode() {
            return Objects.hash(generated);
        }

        @Override
        public String toString() {
            return "FlattenedRecord{" +
                   "generated=" + generated +
                   '}';
        }
    }

    private static class Record {
        private String id;
        private String attribute;
        private Instant createdDate;
        private Instant lastUpdatedDate;
        private Instant convertedLastUpdatedDate;
        private Instant lastUpdatedDateInEpochMillis;
        private FlattenedRecord flattenedRecord;
        private NestedLevel1 nestedLevel1;

        private String getId() {
            return id;
        }

        private Record setId(String id) {
            this.id = id;
            return this;
        }

        private String getAttribute() {
            return attribute;
        }

        private Record setAttribute(String attribute) {
            this.attribute = attribute;
            return this;
        }

        private Instant getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        private Record setLastUpdatedDate(Instant lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        private Instant getCreatedDate() {
            return createdDate;
        }

        private Record setCreatedDate(Instant createdDate) {
            this.createdDate = createdDate;
            return this;
        }

        private Instant getConvertedLastUpdatedDate() {
            return convertedLastUpdatedDate;
        }

        private Record setConvertedLastUpdatedDate(Instant convertedLastUpdatedDate) {
            this.convertedLastUpdatedDate = convertedLastUpdatedDate;
            return this;
        }

        private Instant getLastUpdatedDateInEpochMillis() {
            return lastUpdatedDateInEpochMillis;
        }

        private Record setLastUpdatedDateInEpochMillis(Instant lastUpdatedDateInEpochMillis) {
            this.lastUpdatedDateInEpochMillis = lastUpdatedDateInEpochMillis;
            return this;
        }

        public FlattenedRecord getFlattenedRecord() {
            return flattenedRecord;
        }

        public Record setFlattenedRecord(FlattenedRecord flattenedRecord) {
            this.flattenedRecord = flattenedRecord;
            return this;
        }

        public NestedLevel1 getNestedRecord() {
            return nestedLevel1;
        }

        public Record setNestedRecord(NestedLevel1 nestedLevel1) {
            this.nestedLevel1 = nestedLevel1;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            Record record = (Record) o;
            return Objects.equals(id, record.id) &&
                   Objects.equals(attribute, record.attribute) &&
                   Objects.equals(lastUpdatedDate, record.lastUpdatedDate) &&
                   Objects.equals(createdDate, record.createdDate) &&
                   Objects.equals(lastUpdatedDateInEpochMillis, record.lastUpdatedDateInEpochMillis) &&
                   Objects.equals(convertedLastUpdatedDate, record.convertedLastUpdatedDate) &&
                   Objects.equals(flattenedRecord, record.flattenedRecord) &&
                   Objects.equals(nestedLevel1, record.nestedLevel1);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, attribute, lastUpdatedDate, createdDate, lastUpdatedDateInEpochMillis,
                                convertedLastUpdatedDate, flattenedRecord, nestedLevel1);
        }

        @Override
        public String toString() {
            return "Record{" +
                   "id='" + id + '\'' +
                   ", attribute='" + attribute + '\'' +
                   ", createdDate=" + createdDate +
                   ", lastUpdatedDate=" + lastUpdatedDate +
                   ", convertedLastUpdatedDate=" + convertedLastUpdatedDate +
                   ", lastUpdatedDateInEpochMillis=" + lastUpdatedDateInEpochMillis +
                   ", flattenedRecord=" + flattenedRecord +
                   ", nestedRecord=" + nestedLevel1 +
                   '}';
        }
    }

    private static class NestedLevel1 {
        private String nestedLevel1Attribute;
        private Instant nestedLevel1TimeAttribute;
        private NestedLevel2 nestedLevel2;

        public String getNestedLevel1Attribute() {
            return nestedLevel1Attribute;
        }

        public NestedLevel1 setNestedLevel1Attribute(String nestedLevel1Attribute) {
            this.nestedLevel1Attribute = nestedLevel1Attribute;
            return this;
        }

        public Instant getNestedLevel1TimeAttribute() {
            return nestedLevel1TimeAttribute;
        }

        public NestedLevel1 setNestedLevel1TimeAttribute(Instant nestedLevel1TimeAttribute) {
            this.nestedLevel1TimeAttribute = nestedLevel1TimeAttribute;
            return this;
        }

        public NestedLevel2 getNestedLevel2() {
            return nestedLevel2;
        }

        public NestedLevel1 setNestedLevel2(NestedLevel2 nestedLevel2) {
            this.nestedLevel2 = nestedLevel2;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            NestedLevel1 nestedLevel1 = (NestedLevel1) o;
            return Objects.equals(nestedLevel1Attribute, nestedLevel1.nestedLevel1Attribute) &&
                   Objects.equals(nestedLevel1TimeAttribute, nestedLevel1.nestedLevel1TimeAttribute) &&
                   Objects.equals(nestedLevel2, nestedLevel1.nestedLevel2);
        }

        @Override
        public int hashCode() {
            return Objects.hash(nestedLevel1Attribute, nestedLevel1TimeAttribute, nestedLevel2);
        }

        @Override
        public String toString() {
            return "nestedLevel1{" +
                   "nestedLevel1Attribute='" + nestedLevel1Attribute + '\'' +
                   ", nestedLevel1TimeAttribute=" + nestedLevel1TimeAttribute +
                   ", nestedLevel2=" + nestedLevel2 +
                   '}';
        }
    }

    private static class NestedLevel2 {
        private String nestedLevel2Attribute;
        private Instant nestedLevel2TimeAttribute;
        private NestedLevel3 nestedLevel3;

        public String getNestedLevel2Attribute() {
            return nestedLevel2Attribute;
        }

        public NestedLevel2 setNestedLevel2Attribute(String nestedLevel2Attribute) {
            this.nestedLevel2Attribute = nestedLevel2Attribute;
            return this;
        }

        public Instant getNestedLevel2TimeAttribute() {
            return nestedLevel2TimeAttribute;
        }

        public NestedLevel2 setNestedLevel2TimeAttribute(Instant nestedLevel2TimeAttribute) {
            this.nestedLevel2TimeAttribute = nestedLevel2TimeAttribute;
            return this;
        }

        public NestedLevel3 getNestedLevel3() {
            return nestedLevel3;
        }

        public NestedLevel2 setNestedLevel3(NestedLevel3 nestedLevel3) {
            this.nestedLevel3 = nestedLevel3;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            NestedLevel2 nestedLevel2 = (NestedLevel2) o;
            return Objects.equals(nestedLevel2Attribute, nestedLevel2.nestedLevel2Attribute) &&
                   Objects.equals(nestedLevel2TimeAttribute, nestedLevel2.nestedLevel2TimeAttribute) &&
                   Objects.equals(nestedLevel3, nestedLevel2.nestedLevel3);
        }

        @Override
        public int hashCode() {
            return Objects.hash(nestedLevel2Attribute, nestedLevel2TimeAttribute, nestedLevel3);
        }

        @Override
        public String toString() {
            return "nestedLevel2{" +
                   "nestedLevel2Attribute='" + nestedLevel2Attribute + '\'' +
                   ", nestedLevel2TimeAttribute=" + nestedLevel2TimeAttribute +
                   ", nestedLevel3=" + nestedLevel3 +
                   '}';
        }
    }

    private static class NestedLevel3 {
        private String nestedLevel3Attribute;
        private Instant nestedLevel3TimeAttribute;
        private NestedLevel4 nestedLevel4;

        public String getNestedLevel3Attribute() {
            return nestedLevel3Attribute;
        }

        public NestedLevel3 setNestedLevel3Attribute(String nestedLevel3Attribute) {
            this.nestedLevel3Attribute = nestedLevel3Attribute;
            return this;
        }

        public Instant getNestedLevel3TimeAttribute() {
            return nestedLevel3TimeAttribute;
        }

        public NestedLevel3 setNestedLevel3TimeAttribute(Instant nestedLevel3TimeAttribute) {
            this.nestedLevel3TimeAttribute = nestedLevel3TimeAttribute;
            return this;
        }

        public NestedLevel4 getNestedLevel4() {
            return nestedLevel4;
        }

        public NestedLevel3 setNestedLevel4(NestedLevel4 nestedLevel4) {
            this.nestedLevel4 = nestedLevel4;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            NestedLevel3 nestedLevel3 = (NestedLevel3) o;
            return Objects.equals(nestedLevel3Attribute, nestedLevel3.nestedLevel3Attribute) &&
                   Objects.equals(nestedLevel3TimeAttribute, nestedLevel3.nestedLevel3TimeAttribute) &&
                   Objects.equals(nestedLevel4, nestedLevel3.nestedLevel4);
        }

        @Override
        public int hashCode() {
            return Objects.hash(nestedLevel3Attribute, nestedLevel3TimeAttribute, nestedLevel4);
        }

        @Override
        public String toString() {
            return "nestedLevel3{" +
                   "nestedLevel3Attribute='" + nestedLevel3Attribute + '\'' +
                   ", nestedLevel3TimeAttribute=" + nestedLevel3TimeAttribute +
                   ", nestedLevel4=" + nestedLevel4 +
                   '}';
        }
    }

    private static class NestedLevel4 {
        private String nestedLevel4Attribute;
        private Instant nestedLevel4TimeAttribute;

        public String getNestedLevel4Attribute() {
            return nestedLevel4Attribute;
        }

        public NestedLevel4 setNestedLevel4Attribute(String nestedLevel4Attribute) {
            this.nestedLevel4Attribute = nestedLevel4Attribute;
            return this;
        }

        public Instant getNestedLevel4TimeAttribute() {
            return nestedLevel4TimeAttribute;
        }

        public NestedLevel4 setNestedLevel4TimeAttribute(Instant nestedLevel4TimeAttribute) {
            this.nestedLevel4TimeAttribute = nestedLevel4TimeAttribute;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            NestedLevel4 nestedLevel4 = (NestedLevel4) o;
            return Objects.equals(nestedLevel4Attribute, nestedLevel4.nestedLevel4Attribute) &&
                   Objects.equals(nestedLevel4TimeAttribute, nestedLevel4.nestedLevel4TimeAttribute);
        }

        @Override
        public int hashCode() {
            return Objects.hash(nestedLevel4Attribute, nestedLevel4TimeAttribute);
        }

        @Override
        public String toString() {
            return "nestedLevel4{" +
                   "nestedLevel4Attribute='" + nestedLevel4Attribute + '\'' +
                   ", nestedLevel4TimeAttribute=" + nestedLevel4TimeAttribute +
                   '}';
        }
    }

    private static class RecordWithStringUpdateDate {
        private String id;
        private String lastUpdatedDate;


        private String getId() {
            return id;
        }

        private RecordWithStringUpdateDate setId(String id) {
            this.id = id;
            return this;
        }


        private String getLastUpdatedDate() {
            return lastUpdatedDate;
        }

        private RecordWithStringUpdateDate setLastUpdatedDate(String lastUpdatedDate) {
            this.lastUpdatedDate = lastUpdatedDate;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            RecordWithStringUpdateDate record = (RecordWithStringUpdateDate) o;
            return Objects.equals(id, record.id) &&
                   Objects.equals(lastUpdatedDate, record.lastUpdatedDate);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, lastUpdatedDate);
        }

        @Override
        public String toString() {
            return "RecordWithStringUpdateDate{" +
                   "id='" + id + '\'' +
                   ", lastUpdatedDate=" + lastUpdatedDate +
                   '}';
        }
    }
}
