/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.ATTR_LEVEL1;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.ID_1;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.NestedStaticChildRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.buildStaticImmutableSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.buildStaticImmutableSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.buildStaticSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.buildStaticSchemaForSimpleRecordWithList;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.Arrays;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.NestedBeanWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.NestedImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.NestedStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.SimpleBeanWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.SimpleImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.NestedStructureTestModels.SimpleStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.mapper.BeanTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.model.IgnoreNullsMode;
import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;

public class NestedUpdateBehaviorTest extends LocalDynamoDbSyncTestBase {

    private static final String TIMESTAMP_STRING = "2019-01-13T14:00:00Z";
    private static final String BASE_TABLE_NAME = "update-behavior-test";
    private static final Clock mockClock = Mockito.mock(Clock.class);
    private static final Instant MOCKED_INSTANT_NOW = Instant.now(Clock.fixed(Instant.parse(TIMESTAMP_STRING), ZoneOffset.UTC));

    private DynamoDbEnhancedClient enhancedClient;
    private String currentTestTableName;

    @Before
    public void beforeClass() {
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_NOW);
        enhancedClient = DynamoDbEnhancedClient.builder()
                                               .dynamoDbClient(getDynamoDbClient())
                                               .extensions(AutoGeneratedTimestampRecordExtension.builder()
                                                                                                .baseClock(mockClock)
                                                                                                .build())
                                               .build();
    }

    @After
    public void deleteTable() {
        try {
            if (currentTestTableName != null) {
                getDynamoDbClient().deleteTable(r -> r.tableName(currentTestTableName));
            }
        } catch (ResourceNotFoundException e) {
            // Table didn't get created, ignore.
        }
    }

    @Test
    public void beanSchema_simpleRecord_writeIfNotExists_isRespected() {
        TableSchema<SimpleBeanWithList> schema = BeanTableSchema.create(SimpleBeanWithList.class);
        DynamoDbTable<SimpleBeanWithList> table =
            createAndPut("simple-bean-write-if-not-exists",
                         schema,
                         new SimpleBeanWithList()
                             .setId(ID_1)
                             .setAttr(ATTR_LEVEL1)
                             .setChildList(Arrays.asList(
                                 new NestedStructureTestModels.SimpleBeanChild().setId("child1").setAttr("attr_child1"),
                                 new NestedStructureTestModels.SimpleBeanChild().setId("child2").setAttr("attr_child2"))));

        SimpleBeanWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);
        assertThat(result.getChildList()).hasSize(2);

        // update with new attr value - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleBeanWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getTime()).isNotNull().isEqualTo(MOCKED_INSTANT_NOW); // timestamp should update

        table.deleteTable();
    }

    @Test
    public void beanSchema_nestedRecord_writeIfNotExists_isRespected() {
        TableSchema<NestedBeanWithList> schema = BeanTableSchema.create(NestedBeanWithList.class);
        DynamoDbTable<NestedBeanWithList> table =
            createAndPut("nested-bean-write-if-not-exists",
                         schema,
                         new NestedBeanWithList()
                             .setId(ID_1)
                             .setAttr(ATTR_LEVEL1)
                             .setLevel2(new NestedStructureTestModels.NestedBeanChild().setAttr("attr_level2")));

        NestedBeanWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");

        // update with new attr values - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        result.getLevel2().setAttr("updated_level2");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedBeanWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getLevel2().getAttr()).isEqualTo("attr_level2"); // should NOT change

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecord_writeIfNotExists_isRespected() {
        TableSchema<SimpleImmutableRecordWithList> schema = ImmutableTableSchema.create(SimpleImmutableRecordWithList.class);
        DynamoDbTable<SimpleImmutableRecordWithList> table =
            createAndPut("simple-immutable-write-if-not-exists",
                         schema,
                         SimpleImmutableRecordWithList
                             .builder()
                             .id(ID_1)
                             .attr(ATTR_LEVEL1)
                             .childList(Arrays.asList(
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child1").attr("attr_child1").build(),
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child2").attr("attr_child2").build()))
                             .build());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);
        assertThat(result.getChildList()).hasSize(2);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change

        table.deleteTable();
    }

    @Test
    public void immutableSchema_nestedRecord_writeIfNotExists_isRespected() {
        TableSchema<NestedImmutableRecordWithList> schema = ImmutableTableSchema.create(NestedImmutableRecordWithList.class);
        DynamoDbTable<NestedImmutableRecordWithList> table =
            createAndPut("nested-immutable-write-if-not-exists",
                         schema,
                         NestedImmutableRecordWithList
                             .builder()
                             .id(ID_1)
                             .attr(ATTR_LEVEL1)
                             .level2(NestedStructureTestModels.NestedImmutableChildRecordWithList
                                         .builder().attr("attr_level2").build())
                             .build());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change

        table.deleteTable();
    }

    @Test
    public void staticSchema_simpleRecord_writeIfNotExists_isRespected() {
        DynamoDbTable<SimpleStaticRecordWithList> table =
            createAndPut("simple-static-write-if-not-exists",
                         buildStaticSchemaForSimpleRecordWithList(),
                         new SimpleStaticRecordWithList()
                             .setId(ID_1)
                             .setAttr(ATTR_LEVEL1));

        SimpleStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change

        table.deleteTable();
    }

    @Test
    public void staticSchema_nestedRecord_writeIfNotExists_isRespected() {
        DynamoDbTable<NestedStaticRecordWithList> table =
            createAndPut(
                "nested-static-write-if-not-exists",
                buildStaticSchemaForNestedRecordWithList(),
                new NestedStaticRecordWithList()
                    .setId(ID_1)
                    .setAttr(ATTR_LEVEL1)
                    .setLevel2(new NestedStaticChildRecordWithList().setAttr("attr_level2")));

        NestedStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        result.getLevel2().setAttr("updated_level2");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getLevel2().getAttr()).isEqualTo("attr_level2"); // should NOT change

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_simpleRecord_writeIfNotExists_isRespected() {
        DynamoDbTable<SimpleImmutableRecordWithList> table =
            createAndPut("simple-static-immutable-write-if-not-exists",
                         buildStaticImmutableSchemaForSimpleRecordWithList(),
                         SimpleImmutableRecordWithList
                             .builder()
                             .id(ID_1)
                             .attr(ATTR_LEVEL1)
                             .childList(Arrays.asList(
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child1").attr("attr_child1").build(),
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child2").attr("attr_child2").build()))
                             .build());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_nestedRecord_writeIfNotExists_isRespected() {
        DynamoDbTable<NestedImmutableRecordWithList> table =
            createAndPut("nested-static-immutable-write-if-not-exists",
                         buildStaticImmutableSchemaForNestedRecordWithList(),
                         NestedImmutableRecordWithList
                             .builder()
                             .id(ID_1)
                             .attr(ATTR_LEVEL1)
                             .level2(NestedStructureTestModels.NestedImmutableChildRecordWithList
                                         .builder().attr("attr_level2").build())
                             .build());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change

        table.deleteTable();
    }

    @Test
    public void beanSchema_simpleRecord_writeAlways_updatesValues() {
        TableSchema<SimpleBeanWithList> schema = BeanTableSchema.create(SimpleBeanWithList.class);
        SimpleBeanWithList initial = new SimpleBeanWithList()
            .setId(ID_1)
            .setAttr(ATTR_LEVEL1)
            .setChildList(Arrays.asList(
                new NestedStructureTestModels.SimpleBeanChild().setId("child1").setAttr("attr_child1"),
                new NestedStructureTestModels.SimpleBeanChild().setId("child2").setAttr("attr_child2")));
        initial.setId("initial_id");
        DynamoDbTable<SimpleBeanWithList> table = createAndPut("simple-bean-write-always", schema, initial);

        SimpleBeanWithList result = table.getItem(r -> r.key(k -> k.partitionValue("initial_id")));
        assertThat(result.getId()).isEqualTo("initial_id");

        // update id (no annotation, defaults to WRITE_ALWAYS) - should change
        result.setId("updated_id");
        table.updateItem(result);

        SimpleBeanWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void beanSchema_nestedRecord_writeAlways_updatesValues() {
        TableSchema<NestedBeanWithList> schema = BeanTableSchema.create(NestedBeanWithList.class);
        NestedBeanWithList initial = new NestedBeanWithList()
            .setId(ID_1)
            .setAttr(ATTR_LEVEL1)
            .setLevel2(new NestedStructureTestModels.NestedBeanChild().setAttr("attr_level2"));
        initial.setId("initial_id");
        DynamoDbTable<NestedBeanWithList> table = createAndPut("nested-bean-write-always", schema, initial);

        NestedBeanWithList result = table.getItem(r -> r.key(k -> k.partitionValue("initial_id")));
        assertThat(result.getId()).isEqualTo("initial_id");

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        NestedBeanWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecord_writeAlways_updatesValues() {
        TableSchema<SimpleImmutableRecordWithList> schema = ImmutableTableSchema.create(SimpleImmutableRecordWithList.class);
        SimpleImmutableRecordWithList initial =
            SimpleImmutableRecordWithList
                .builder()
                .id(ID_1)
                .attr(ATTR_LEVEL1)
                .childList(Arrays.asList(
                    NestedStructureTestModels.SimpleImmutableChild.builder().id("child1").attr("attr_child1").build(),
                    NestedStructureTestModels.SimpleImmutableChild.builder().id("child2").attr("attr_child2").build()))
                .build();

        DynamoDbTable<SimpleImmutableRecordWithList> table = createAndPut("simple-immutable-write-always", schema, initial);

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void immutableSchema_nestedRecord_writeAlways_updatesValues() {
        TableSchema<NestedImmutableRecordWithList> schema = ImmutableTableSchema.create(NestedImmutableRecordWithList.class);
        NestedImmutableRecordWithList initial =
            NestedImmutableRecordWithList
                .builder()
                .id(ID_1)
                .attr(ATTR_LEVEL1)
                .level2(NestedStructureTestModels.NestedImmutableChildRecordWithList
                            .builder().attr("attr_level2").build())
                .build();
        DynamoDbTable<NestedImmutableRecordWithList> table = createAndPut("nested-immutable-write-always", schema, initial);

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void staticSchema_simpleRecord_writeAlways_updatesValues() {
        DynamoDbTable<SimpleStaticRecordWithList> table =
            createAndPut("simple-static-write-always",
                         buildStaticSchemaForSimpleRecordWithList(),
                         new SimpleStaticRecordWithList()
                             .setId(ID_1)
                             .setAttr(ATTR_LEVEL1));

        SimpleStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        SimpleStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void staticSchema_nestedRecord_writeAlways_updatesValues() {
        DynamoDbTable<NestedStaticRecordWithList> table = createAndPut(
            "nested-static-write-always",
            buildStaticSchemaForNestedRecordWithList(),
            new NestedStaticRecordWithList()
                .setId(ID_1)
                .setAttr(ATTR_LEVEL1)
                .setLevel2(new NestedStructureTestModels.NestedStaticChildRecordWithList().setAttr("attr_level2")));

        NestedStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        NestedStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_simpleRecord_writeAlways_updatesValues() {
        DynamoDbTable<SimpleImmutableRecordWithList> table =
            createAndPut("simple-static-immutable-write-always",
                         buildStaticImmutableSchemaForSimpleRecordWithList(),
                         SimpleImmutableRecordWithList
                             .builder()
                             .id(ID_1)
                             .attr(ATTR_LEVEL1)
                             .childList(Arrays.asList(
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child1").attr("attr_child1").build(),
                                 NestedStructureTestModels.SimpleImmutableChild.builder().id("child2").attr("attr_child2").build()))
                             .build());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_nestedRecord_writeAlways_updatesValues() {
        DynamoDbTable<NestedImmutableRecordWithList> table =
            createAndPut("nested-static-immutable-write-always",
                         buildStaticImmutableSchemaForNestedRecordWithList(),
                         NestedImmutableRecordWithList.builder()
                                                      .id(ID_1)
                                                      .attr(ATTR_LEVEL1)
                                                      .level2(NestedStructureTestModels.NestedImmutableChildRecordWithList
                                                                  .builder().attr("attr_level2").build())
                                                      .build());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");

        table.deleteTable();
    }

    private <T> DynamoDbTable<T> createAndPut(String tableSuffix, TableSchema<T> schema, T item) {
        currentTestTableName = BASE_TABLE_NAME + tableSuffix + System.nanoTime();
        DynamoDbTable<T> table = enhancedClient.table(currentTestTableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(item);
        return table;
    }
}
