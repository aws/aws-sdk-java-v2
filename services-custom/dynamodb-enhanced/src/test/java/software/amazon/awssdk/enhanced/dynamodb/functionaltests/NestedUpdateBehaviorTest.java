/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.ATTR_LEVEL1;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.ID_1;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildBeanSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildBeanSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildImmutableSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildImmutableSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildNestedBeanRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildNestedImmutableRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildNestedStaticRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildSimpleBeanRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildSimpleImmutableRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildSimpleStaticRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildStaticImmutableSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildStaticImmutableSchemaForSimpleRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildStaticSchemaForNestedRecordWithList;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.buildStaticSchemaForSimpleRecordWithList;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Collectors;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedBeanRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.NestedStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.SimpleBeanRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.SimpleImmutableRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.AutogeneratedTimestampModels.SimpleStaticRecordWithList;
import software.amazon.awssdk.enhanced.dynamodb.model.IgnoreNullsMode;
import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;

@RunWith(Parameterized.class)
public class NestedUpdateBehaviorTest extends LocalDynamoDbSyncTestBase {

    private static final String TIMESTAMP_STRING = "2019-01-13T14:00:00Z";
    private static final String BASE_TABLE_NAME = "update-behavior-test";
    private static final String SIMPLE_BEAN_TABLE_SUFFIX = "-simple-bean-";
    private static final String NESTED_BEAN_TABLE_SUFFIX = "-nested-bean-";
    private static final String SIMPLE_IMMUTABLE_TABLE_SUFFIX = "-simple-immutable-";
    private static final String NESTED_IMMUTABLE_TABLE_SUFFIX = "-nested-immutable-";
    private static final String SIMPLE_STATIC_TABLE_SUFFIX = "-simple-static-";
    private static final String NESTED_STATIC_TABLE_SUFFIX = "-nested-static-";
    private static final String SIMPLE_STATIC_IMMUTABLE_TABLE_SUFFIX = "-simple-static-immutable-";
    private static final String NESTED_STATIC_IMMUTABLE_TABLE_SUFFIX = "-nested-static-immutable-";

    private static final Clock mockClock = Mockito.mock(Clock.class);
    private static final Instant MOCKED_INSTANT_NOW =
        Instant.now(Clock.fixed(Instant.parse(TIMESTAMP_STRING), ZoneOffset.UTC));
    private DynamoDbEnhancedClient enhancedClient;
    private String currentTestTableName;

    private enum RecordLevel {SIMPLE, NESTED}

    private enum SchemaType {BEAN, IMMUTABLE, STATIC, STATIC_IMMUTABLE}

    @Parameterized.Parameters(name = "{0}-{1}")
    public static Collection<Object[]> data() {
        return Arrays.stream(SchemaType.values())
                     .flatMap(schema -> Arrays.stream(RecordLevel.values())
                                              .map(level -> new Object[] {schema, level}))
                     .collect(Collectors.toList());
    }

    @Parameterized.Parameter(0)
    public SchemaType schemaType;

    @Parameterized.Parameter(1)
    public RecordLevel recordLevel;

    @Before
    public void beforeClass() {
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_NOW);
        enhancedClient = DynamoDbEnhancedClient.builder()
                                               .dynamoDbClient(getDynamoDbClient())
                                               .extensions(AutoGeneratedTimestampRecordExtension.builder()
                                                                                                .baseClock(mockClock)
                                                                                                .build())
                                               .build();
    }

    @After
    public void deleteTable() {
        try {
            if (currentTestTableName != null) {
                getDynamoDbClient().deleteTable(r -> r.tableName(currentTestTableName));
            }
        } catch (ResourceNotFoundException e) {
            // Table didn't get created, ignore.
        }
    }

    @Test
    public void updateBehavior_writeIfNotExists_isRespectedOnNestedObjects() {
        switch (schemaType) {
            case BEAN:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleBeanUpdateBehavior();
                } else {
                    testNestedBeanUpdateBehavior();
                }
                break;
            case IMMUTABLE:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleImmutableUpdateBehavior();
                } else {
                    testNestedImmutableUpdateBehavior();
                }
                break;
            case STATIC:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleStaticUpdateBehavior();
                } else {
                    testNestedStaticUpdateBehavior();
                }
                break;
            case STATIC_IMMUTABLE:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleStaticImmutableUpdateBehavior();
                } else {
                    testNestedStaticImmutableUpdateBehavior();
                }
                break;
        }
    }

    private void testSimpleBeanUpdateBehavior() {
        TableSchema<SimpleBeanRecordWithList> schema = buildBeanSchemaForSimpleRecordWithList();
        DynamoDbTable<SimpleBeanRecordWithList> table = createAndPut(SIMPLE_BEAN_TABLE_SUFFIX,
                                                                     schema,
                                                                     buildSimpleBeanRecordWithList());

        SimpleBeanRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);
        assertThat(result.getChildList()).hasSize(2);

        // update with new attr value - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleBeanRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getTime()).isNotNull().isEqualTo(MOCKED_INSTANT_NOW); // timestamp should update
    }

    private void testNestedBeanUpdateBehavior() {
        TableSchema<NestedBeanRecordWithList> schema = buildBeanSchemaForNestedRecordWithList();
        DynamoDbTable<NestedBeanRecordWithList> table = createAndPut(NESTED_BEAN_TABLE_SUFFIX,
                                                                     schema,
                                                                     buildNestedBeanRecordWithList());

        NestedBeanRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");
        assertThat(result.getLevel2().getLevel3()).isNotNull();
        assertThat(result.getLevel2().getLevel3().getAttr()).isEqualTo("attr_level3");
        assertThat(result.getLevel2().getLevel3().getLevel4()).isNotNull();
        assertThat(result.getLevel2().getLevel3().getLevel4().getAttr()).isEqualTo("attr_level4");

        // update with new attr values - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        result.getLevel2().setAttr("updated_level2");
        result.getLevel2().getLevel3().setAttr("updated_level3");
        result.getLevel2().getLevel3().getLevel4().setAttr("updated_level4");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedBeanRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getLevel2().getAttr()).isEqualTo("attr_level2"); // should NOT change
        assertThat(updated.getLevel2().getLevel3().getAttr()).isEqualTo("attr_level3"); // should NOT change
        assertThat(updated.getLevel2().getLevel3().getLevel4().getAttr()).isEqualTo("attr_level4"); // should NOT change
    }

    private void testSimpleImmutableUpdateBehavior() {
        TableSchema<SimpleImmutableRecordWithList> schema = buildImmutableSchemaForSimpleRecordWithList();
        DynamoDbTable<SimpleImmutableRecordWithList> table = createAndPut(SIMPLE_IMMUTABLE_TABLE_SUFFIX,
                                                                          schema,
                                                                          buildSimpleImmutableRecordWithList());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);
        assertThat(result.getChildList()).hasSize(2);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
    }

    private void testNestedImmutableUpdateBehavior() {
        TableSchema<NestedImmutableRecordWithList> schema = buildImmutableSchemaForNestedRecordWithList();
        DynamoDbTable<NestedImmutableRecordWithList> table = createAndPut(NESTED_IMMUTABLE_TABLE_SUFFIX,
                                                                          schema,
                                                                          buildNestedImmutableRecordWithList());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");
        assertThat(result.getLevel2().getLevel3()).isNotNull();
        assertThat(result.getLevel2().getLevel3().getAttr()).isEqualTo("attr_level3");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
    }

    private void testSimpleStaticUpdateBehavior() {
        DynamoDbTable<SimpleStaticRecordWithList> table = createAndPut(SIMPLE_STATIC_TABLE_SUFFIX,
                                                                       buildStaticSchemaForSimpleRecordWithList(),
                                                                       buildSimpleStaticRecordWithList());

        SimpleStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
    }

    private void testNestedStaticUpdateBehavior() {
        DynamoDbTable<NestedStaticRecordWithList> table = createAndPut(NESTED_STATIC_TABLE_SUFFIX,
                                                                       buildStaticSchemaForNestedRecordWithList(),
                                                                       buildNestedStaticRecordWithList());

        NestedStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");
        assertThat(result.getLevel2().getLevel3()).isNotNull();
        assertThat(result.getLevel2().getLevel3().getAttr()).isEqualTo("attr_level3");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        result.setAttr("updated_level1");
        result.getLevel2().setAttr("updated_level2");
        result.getLevel2().getLevel3().setAttr("updated_level3");
        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(updated.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
        assertThat(updated.getLevel2().getAttr()).isEqualTo("attr_level2"); // should NOT change
        assertThat(updated.getLevel2().getLevel3().getAttr()).isEqualTo("attr_level3"); // should NOT change
    }

    private void testSimpleStaticImmutableUpdateBehavior() {
        DynamoDbTable<SimpleImmutableRecordWithList> table = createAndPut(SIMPLE_STATIC_IMMUTABLE_TABLE_SUFFIX,
                                                                          buildStaticImmutableSchemaForSimpleRecordWithList(),
                                                                          buildSimpleImmutableRecordWithList());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getTime()).isEqualTo(MOCKED_INSTANT_NOW);

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
    }

    private void testNestedStaticImmutableUpdateBehavior() {
        DynamoDbTable<NestedImmutableRecordWithList> table = createAndPut(NESTED_STATIC_IMMUTABLE_TABLE_SUFFIX,
                                                                          buildStaticImmutableSchemaForNestedRecordWithList(),
                                                                          buildNestedImmutableRecordWithList());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getAttr()).isEqualTo(ATTR_LEVEL1);
        assertThat(result.getLevel2()).isNotNull();
        assertThat(result.getLevel2().getAttr()).isEqualTo("attr_level2");

        // update with new attr - should NOT change due to WRITE_IF_NOT_EXISTS (requires SCALAR_ONLY mode)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id(ID_1).attr("updated_level1")
                                                                             .build();
        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(afterUpdate.getAttr()).isEqualTo(ATTR_LEVEL1); // should NOT change
    }

    @Test
    public void updateBehavior_writeAlways_updatesValuesOnNestedObjects() {
        // WRITE_ALWAYS is the default behavior, so we test that id field (without annotation) updates correctly
        switch (schemaType) {
            case BEAN:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleBeanWriteAlways();
                } else {
                    testNestedBeanWriteAlways();
                }
                break;
            case IMMUTABLE:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleImmutableWriteAlways();
                } else {
                    testNestedImmutableWriteAlways();
                }
                break;
            case STATIC:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleStaticWriteAlways();
                } else {
                    testNestedStaticWriteAlways();
                }
                break;
            case STATIC_IMMUTABLE:
                if (recordLevel == RecordLevel.SIMPLE) {
                    testSimpleStaticImmutableWriteAlways();
                } else {
                    testNestedStaticImmutableWriteAlways();
                }
                break;
        }
    }

    private void testSimpleBeanWriteAlways() {
        TableSchema<SimpleBeanRecordWithList> schema = buildBeanSchemaForSimpleRecordWithList();
        SimpleBeanRecordWithList initial = buildSimpleBeanRecordWithList();
        initial.setId("initial_id");
        DynamoDbTable<SimpleBeanRecordWithList> table = createAndPut(SIMPLE_BEAN_TABLE_SUFFIX, schema, initial);

        SimpleBeanRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue("initial_id")));
        assertThat(result.getId()).isEqualTo("initial_id");

        // update id (no annotation, defaults to WRITE_ALWAYS) - should change
        result.setId("updated_id");
        table.updateItem(result);

        SimpleBeanRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");
    }

    private void testNestedBeanWriteAlways() {
        TableSchema<NestedBeanRecordWithList> schema = buildBeanSchemaForNestedRecordWithList();
        NestedBeanRecordWithList initial = buildNestedBeanRecordWithList();
        initial.setId("initial_id");
        DynamoDbTable<NestedBeanRecordWithList> table = createAndPut(NESTED_BEAN_TABLE_SUFFIX, schema, initial);

        NestedBeanRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue("initial_id")));
        assertThat(result.getId()).isEqualTo("initial_id");

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        NestedBeanRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");
    }

    private void testSimpleImmutableWriteAlways() {
        TableSchema<SimpleImmutableRecordWithList> schema = buildImmutableSchemaForSimpleRecordWithList();
        SimpleImmutableRecordWithList initial = buildSimpleImmutableRecordWithList();
        DynamoDbTable<SimpleImmutableRecordWithList> table = createAndPut(SIMPLE_IMMUTABLE_TABLE_SUFFIX, schema, initial);

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");
    }

    private void testNestedImmutableWriteAlways() {
        TableSchema<NestedImmutableRecordWithList> schema = buildImmutableSchemaForNestedRecordWithList();
        NestedImmutableRecordWithList initial = buildNestedImmutableRecordWithList();
        DynamoDbTable<NestedImmutableRecordWithList> table = createAndPut(NESTED_IMMUTABLE_TABLE_SUFFIX, schema, initial);

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");
    }

    private void testSimpleStaticWriteAlways() {
        DynamoDbTable<SimpleStaticRecordWithList> table = createAndPut(SIMPLE_STATIC_TABLE_SUFFIX,
                                                                       buildStaticSchemaForSimpleRecordWithList(),
                                                                       buildSimpleStaticRecordWithList());

        SimpleStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        SimpleStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");
    }

    private void testNestedStaticWriteAlways() {
        DynamoDbTable<NestedStaticRecordWithList> table = createAndPut(NESTED_STATIC_TABLE_SUFFIX,
                                                                       buildStaticSchemaForNestedRecordWithList(),
                                                                       buildNestedStaticRecordWithList());

        NestedStaticRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update id - should change (WRITE_ALWAYS is default)
        result.setId("updated_id");
        table.updateItem(result);

        NestedStaticRecordWithList updated = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(updated).isNotNull();
        assertThat(updated.getId()).isEqualTo("updated_id");
    }

    private void testSimpleStaticImmutableWriteAlways() {
        DynamoDbTable<SimpleImmutableRecordWithList> table = createAndPut(SIMPLE_STATIC_IMMUTABLE_TABLE_SUFFIX,
                                                                          buildStaticImmutableSchemaForSimpleRecordWithList(),
                                                                          buildSimpleImmutableRecordWithList());

        SimpleImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        SimpleImmutableRecordWithList updated = SimpleImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        SimpleImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");
    }

    private void testNestedStaticImmutableWriteAlways() {
        DynamoDbTable<NestedImmutableRecordWithList> table = createAndPut(NESTED_STATIC_IMMUTABLE_TABLE_SUFFIX,
                                                                          buildStaticImmutableSchemaForNestedRecordWithList(),
                                                                          buildNestedImmutableRecordWithList());

        NestedImmutableRecordWithList result = table.getItem(r -> r.key(k -> k.partitionValue(ID_1)));
        assertThat(result.getId()).isEqualTo(ID_1);

        // update with new id - should change (WRITE_ALWAYS is default)
        NestedImmutableRecordWithList updated = NestedImmutableRecordWithList.builder()
                                                                             .id("updated_id").attr(ATTR_LEVEL1)
                                                                             .build();
        table.updateItem(updated);

        NestedImmutableRecordWithList afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("updated_id")));
        assertThat(afterUpdate).isNotNull();
        assertThat(afterUpdate.getId()).isEqualTo("updated_id");
    }

    private <T> DynamoDbTable<T> createAndPut(String tableSuffix, TableSchema<T> schema, T item) {
        currentTestTableName = BASE_TABLE_NAME + tableSuffix + System.nanoTime();
        DynamoDbTable<T> table = enhancedClient.table(currentTestTableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(item);
        return table;
    }
}
