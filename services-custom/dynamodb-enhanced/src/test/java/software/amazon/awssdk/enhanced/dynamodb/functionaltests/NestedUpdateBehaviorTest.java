/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalStateException;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.NestedStaticChildRecord;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticImmutableSchemaForNestedRecord;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticImmutableSchemaForSimpleRecord;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticImmutableSchema_NoChildSchemaDefined;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticSchemaForNestedRecord;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticSchemaForNestedRecord_NoChildSchemaDefined;
import static software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.buildStaticSchemaForSimpleRecord;

import java.time.Clock;
import java.time.Instant;
import java.time.ZoneOffset;
import java.util.Arrays;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.NestedBean;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.NestedImmutableRecord;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.NestedStaticRecord;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.SimpleBean;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.SimpleImmutableRecord;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.models.UpdateBehaviorTestModels.SimpleStaticRecord;
import software.amazon.awssdk.enhanced.dynamodb.mapper.BeanTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;
import software.amazon.awssdk.enhanced.dynamodb.model.IgnoreNullsMode;
import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;

public class NestedUpdateBehaviorTest extends LocalDynamoDbSyncTestBase {

    private static final String TIMESTAMP_STRING = "2019-01-13T14:00:00Z";
    private static final String BASE_TABLE_NAME = "update-behavior-test";
    private static final Clock mockClock = Mockito.mock(Clock.class);
    private static final Instant MOCKED_INSTANT_NOW = Instant.now(Clock.fixed(Instant.parse(TIMESTAMP_STRING), ZoneOffset.UTC));

    private DynamoDbEnhancedClient enhancedClient;
    private String currentTestTableName;

    @Before
    public void beforeClass() {
        Mockito.when(mockClock.instant()).thenReturn(MOCKED_INSTANT_NOW);
        enhancedClient = DynamoDbEnhancedClient.builder()
                                               .dynamoDbClient(getDynamoDbClient())
                                               .extensions(AutoGeneratedTimestampRecordExtension.builder()
                                                                                                .baseClock(mockClock)
                                                                                                .build())
                                               .build();
    }

    @After
    public void deleteTable() {
        try {
            if (currentTestTableName != null) {
                getDynamoDbClient().deleteTable(r -> r.tableName(currentTestTableName));
            }
        } catch (ResourceNotFoundException e) {
            // Table didn't get created, ignore.
        }
    }

    @Test
    public void beanSchema_simpleRecord_updateBehavior_isRespected() {
        TableSchema<SimpleBean> schema = BeanTableSchema.create(SimpleBean.class);

        SimpleBean item = UpdateBehaviorTestModels.createSimpleBean();

        DynamoDbTable<SimpleBean> table = createAndPut("simple-bean-update-behavior", schema, item);

        SimpleBean result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChildList()).hasSize(2);

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        // Note: We only update root-level attributes, not child list items, because
        // list updates replace the entire list, overriding individual child update behaviors
        result.setWriteAlwaysField("updated_writeAlways");
        result.setWriteOnceField("updated_writeOnce");

        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleBean updated = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(updated.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(updated.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        // Child list should remain unchanged since we didn't update it
        assertThat(updated.getChildList()).hasSize(2);
        assertThat(updated.getChildList().get(0).getChildAlwaysUpdate()).isEqualTo("child1_initial_writeAlways");
        assertThat(updated.getChildList().get(0).getChildWriteOnce()).isEqualTo("child1_initial_writeOnce");
        assertThat(updated.getChildList().get(1).getChildAlwaysUpdate()).isEqualTo("child2_initial_writeAlways");
        assertThat(updated.getChildList().get(1).getChildWriteOnce()).isEqualTo("child2_initial_writeOnce");

        table.deleteTable();
    }

    @Test
    public void beanSchema_nestedRecord_updateBehavior_isRespected() {
        TableSchema<NestedBean> schema = BeanTableSchema.create(NestedBean.class);

        NestedBean item = UpdateBehaviorTestModels.createNestedBean();

        DynamoDbTable<NestedBean> table = createAndPut("nested-bean-update-behavior", schema, item);

        NestedBean result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChild()).isNotNull();
        assertThat(result.getChild().getChildAlwaysUpdate()).isEqualTo("child_initial_writeAlways");
        assertThat(result.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce");

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        result.setWriteAlwaysField("updated_writeAlways");
        result.setWriteOnceField("updated_writeOnce");
        result.getChild().setChildAlwaysUpdate("child_updated_writeAlways");
        result.getChild().setChildWriteOnce("child_updated_writeOnce");

        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedBean updated = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(updated.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(updated.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        // Child level assertions
        assertThat(updated.getChild().getChildAlwaysUpdate()).isEqualTo("child_updated_writeAlways"); // WRITE_ALWAYS: should
        // change
        assertThat(updated.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should
        // NOT change

        table.deleteTable();
    }

    @Test
    public void immutableSchema_simpleRecord_updateBehavior_isRespected() {
        TableSchema<SimpleImmutableRecord> schema = ImmutableTableSchema.create(SimpleImmutableRecord.class);

        SimpleImmutableRecord item = SimpleImmutableRecord
            .builder()
            .id("1")
            .writeAlwaysField("initial_writeAlways")
            .writeOnceField("initial_writeOnce")
            .childList(Arrays.asList(
                UpdateBehaviorTestModels.SimpleImmutableChild.builder()
                                                             .id("child1")
                                                             .childAlwaysUpdate("child1_initial_writeAlways")
                                                             .childWriteOnce("child1_initial_writeOnce")
                                                             .build(),
                UpdateBehaviorTestModels.SimpleImmutableChild.builder()
                                                             .id("child2")
                                                             .childAlwaysUpdate("child2_initial_writeAlways")
                                                             .childWriteOnce("child2_initial_writeOnce")
                                                             .build()))
            .build();

        DynamoDbTable<SimpleImmutableRecord> table = createAndPut("simple-immutable-update-behavior", schema, item);

        SimpleImmutableRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChildList()).hasSize(2);

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        // Note: We only update root-level attributes, not child list items, because
        // list updates replace the entire list, overriding individual child update behaviors
        SimpleImmutableRecord updated = SimpleImmutableRecord.builder()
                                                             .id("1")
                                                             .writeAlwaysField("updated_writeAlways")
                                                             .writeOnceField("updated_writeOnce")
                                                             .build();

        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecord afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(afterUpdate.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(afterUpdate.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        // Child list should remain unchanged since we didn't update it
        assertThat(afterUpdate.getChildList()).hasSize(2);
        assertThat(afterUpdate.getChildList().get(0).getChildAlwaysUpdate()).isEqualTo("child1_initial_writeAlways");
        assertThat(afterUpdate.getChildList().get(0).getChildWriteOnce()).isEqualTo("child1_initial_writeOnce");
        assertThat(afterUpdate.getChildList().get(1).getChildAlwaysUpdate()).isEqualTo("child2_initial_writeAlways");
        assertThat(afterUpdate.getChildList().get(1).getChildWriteOnce()).isEqualTo("child2_initial_writeOnce");

        table.deleteTable();
    }

    @Test
    public void immutableSchema_nestedRecord_updateBehavior_isRespected() {
        TableSchema<NestedImmutableRecord> schema = ImmutableTableSchema.create(NestedImmutableRecord.class);

        NestedImmutableRecord item = NestedImmutableRecord
            .builder()
            .id("1")
            .writeAlwaysField("initial_writeAlways")
            .writeOnceField("initial_writeOnce")
            .child(UpdateBehaviorTestModels.NestedImmutableChild
                       .builder()
                       .childAlwaysUpdate("child_initial_writeAlways")
                       .childWriteOnce("child_initial_writeOnce")
                       .build())
            .build();

        DynamoDbTable<NestedImmutableRecord> table = createAndPut("nested-immutable-update-behavior", schema, item);

        NestedImmutableRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChild()).isNotNull();
        assertThat(result.getChild().getChildAlwaysUpdate()).isEqualTo("child_initial_writeAlways");
        assertThat(result.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce");

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        NestedImmutableRecord updated = NestedImmutableRecord.builder()
                                                             .id("1")
                                                             .writeAlwaysField("updated_writeAlways")
                                                             .writeOnceField("updated_writeOnce")
                                                             .build();

        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecord afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(afterUpdate.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(afterUpdate.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        table.deleteTable();
    }

    @Test
    public void staticSchema_simpleRecord_updateBehavior_isRespected() {
        SimpleStaticRecord item = new SimpleStaticRecord()
            .setId("1")
            .setWriteAlwaysField("initial_writeAlways")
            .setWriteOnceField("initial_writeOnce");

        DynamoDbTable<SimpleStaticRecord> table = createAndPut("simple-static-update-behavior",
                                                               buildStaticSchemaForSimpleRecord(), item);

        SimpleStaticRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        result.setWriteAlwaysField("updated_writeAlways");
        result.setWriteOnceField("updated_writeOnce");

        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleStaticRecord updated = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(updated.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(updated.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        table.deleteTable();
    }

    @Test
    public void staticSchema_nestedRecord_updateBehavior_isRespected() {
        NestedStaticRecord item = new NestedStaticRecord()
            .setId("1")
            .setWriteAlwaysField("initial_writeAlways")
            .setWriteOnceField("initial_writeOnce")
            .setChild(new NestedStaticChildRecord()
                          .setChildAlwaysUpdate("child_initial_writeAlways")
                          .setChildWriteOnce("child_initial_writeOnce"));

        DynamoDbTable<NestedStaticRecord> table = createAndPut("nested-static-update-behavior",
                                                               buildStaticSchemaForNestedRecord(), item);

        NestedStaticRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChild()).isNotNull();
        assertThat(result.getChild().getChildAlwaysUpdate()).isEqualTo("child_initial_writeAlways");
        assertThat(result.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce");

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        result.setWriteAlwaysField("updated_writeAlways");
        result.setWriteOnceField("updated_writeOnce");
        result.getChild().setChildAlwaysUpdate("child_updated_writeAlways");
        result.getChild().setChildWriteOnce("child_updated_writeOnce");

        table.updateItem(r -> r.item(result).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedStaticRecord updated = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // Root level assertions
        assertThat(updated.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // WRITE_ALWAYS: should change
        assertThat(updated.getWriteOnceField()).isEqualTo("initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should NOT change

        // Child level assertions
        assertThat(updated.getChild().getChildAlwaysUpdate()).isEqualTo("child_updated_writeAlways"); // WRITE_ALWAYS: should
        // change
        assertThat(updated.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce"); // WRITE_IF_NOT_EXISTS: should
        // NOT change

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_simpleRecord_updateBehavior_isRespected() {
        SimpleImmutableRecord item = SimpleImmutableRecord
            .builder()
            .id("1")
            .writeAlwaysField("initial_writeAlways")
            .writeOnceField("initial_writeOnce")
            .childList(Arrays.asList(
                UpdateBehaviorTestModels.SimpleImmutableChild.builder()
                                                             .id("child1")
                                                             .childAlwaysUpdate("child1_initial_writeAlways")
                                                             .childWriteOnce("child1_initial_writeOnce")
                                                             .build(),
                UpdateBehaviorTestModels.SimpleImmutableChild.builder()
                                                             .id("child2")
                                                             .childAlwaysUpdate("child2_initial_writeAlways")
                                                             .childWriteOnce("child2_initial_writeOnce")
                                                             .build()))
            .build();

        DynamoDbTable<SimpleImmutableRecord> table = createAndPut("simple-static-immutable-update-behavior",
                                                                  buildStaticImmutableSchemaForSimpleRecord(), item);

        SimpleImmutableRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChildList()).hasSize(2);

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        // Note: We only update root-level attributes, not child list items, because
        // list updates replace the entire list, overriding individual child update behaviors
        SimpleImmutableRecord updated = SimpleImmutableRecord.builder()
                                                             .id("1")
                                                             .writeAlwaysField("updated_writeAlways")
                                                             .writeOnceField("updated_writeOnce")
                                                             .build();

        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        SimpleImmutableRecord afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // WRITE_ALWAYS fields should be updated
        assertThat(afterUpdate.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // should change

        // WRITE_IF_NOT_EXISTS fields should NOT be updated (keep original values)
        assertThat(afterUpdate.getWriteOnceField()).isEqualTo("initial_writeOnce"); // should NOT change

        // Child list should remain unchanged since we didn't update it
        assertThat(afterUpdate.getChildList()).hasSize(2);
        assertThat(afterUpdate.getChildList().get(0).getChildAlwaysUpdate()).isEqualTo("child1_initial_writeAlways");
        assertThat(afterUpdate.getChildList().get(0).getChildWriteOnce()).isEqualTo("child1_initial_writeOnce");
        assertThat(afterUpdate.getChildList().get(1).getChildAlwaysUpdate()).isEqualTo("child2_initial_writeAlways");
        assertThat(afterUpdate.getChildList().get(1).getChildWriteOnce()).isEqualTo("child2_initial_writeOnce");

        table.deleteTable();
    }

    @Test
    public void staticImmutableSchema_nestedRecord_updateBehavior_isRespected() {
        NestedImmutableRecord item = NestedImmutableRecord.builder()
                                                          .id("1")
                                                          .writeAlwaysField("initial_writeAlways")
                                                          .writeOnceField("initial_writeOnce")
                                                          .child(UpdateBehaviorTestModels.NestedImmutableChild
                                                                     .builder()
                                                                     .childAlwaysUpdate("child_initial_writeAlways")
                                                                     .childWriteOnce("child_initial_writeOnce")
                                                                     .build())
                                                          .build();

        DynamoDbTable<NestedImmutableRecord> table = createAndPut("nested-static-immutable-update-behavior",
                                                                  buildStaticImmutableSchemaForNestedRecord(), item);

        NestedImmutableRecord result = table.getItem(r -> r.key(k -> k.partitionValue("1")));
        assertThat(result.getWriteAlwaysField()).isEqualTo("initial_writeAlways");
        assertThat(result.getWriteOnceField()).isEqualTo("initial_writeOnce");
        assertThat(result.getChild()).isNotNull();
        assertThat(result.getChild().getChildAlwaysUpdate()).isEqualTo("child_initial_writeAlways");
        assertThat(result.getChild().getChildWriteOnce()).isEqualTo("child_initial_writeOnce");

        // Update with new values for both WRITE_ALWAYS and WRITE_IF_NOT_EXISTS fields
        NestedImmutableRecord updated = NestedImmutableRecord.builder()
                                                             .id("1")
                                                             .writeAlwaysField("updated_writeAlways")
                                                             .writeOnceField("updated_writeOnce")
                                                             .build();

        table.updateItem(r -> r.item(updated).ignoreNullsMode(IgnoreNullsMode.SCALAR_ONLY));

        NestedImmutableRecord afterUpdate = table.getItem(r -> r.key(k -> k.partitionValue("1")));

        // WRITE_ALWAYS fields should be updated
        assertThat(afterUpdate.getWriteAlwaysField()).isEqualTo("updated_writeAlways"); // should change

        // WRITE_IF_NOT_EXISTS fields should NOT be updated (keep original values)
        assertThat(afterUpdate.getWriteOnceField()).isEqualTo("initial_writeOnce"); // should NOT change

        table.deleteTable();
    }

    @Test
    public void buildStaticSchema_forNestedRecordWithChildSchemaNotDefined_throwsIllegalStateException() {
        NestedStaticRecord item = new NestedStaticRecord()
            .setId("1")
            .setWriteAlwaysField("initial_writeAlways")
            .setWriteOnceField("initial_writeOnce")
            .setChild(new NestedStaticChildRecord()
                          .setChildAlwaysUpdate("child_initial_writeAlways")
                          .setChildWriteOnce("child_initial_writeOnce"));

        assertThatIllegalStateException()
            .isThrownBy(() -> createAndPut("nested-static-update-behavior",
                                           buildStaticSchemaForNestedRecord_NoChildSchemaDefined(),
                                           item))

            .withMessageContaining("Converter not found for EnhancedType(software.amazon.awssdk.enhanced.dynamodb"
                                   + ".functionaltests.models.UpdateBehaviorTestModels$NestedStaticChildRecord)");
    }

    @Test
    public void buildStaticImmutableSchema_forNestedRecordWithChildSchemaNotDefined_throwsIllegalStateException() {
        NestedImmutableRecord item = NestedImmutableRecord.builder()
                                                          .id("1")
                                                          .writeAlwaysField("initial_writeAlways")
                                                          .writeOnceField("initial_writeOnce")
                                                          .child(UpdateBehaviorTestModels.NestedImmutableChild
                                                                     .builder()
                                                                     .childAlwaysUpdate("child_initial_writeAlways")
                                                                     .childWriteOnce("child_initial_writeOnce")
                                                                     .build())
                                                          .build();

        assertThatIllegalStateException()
            .isThrownBy(() -> createAndPut("nested-static-immutable-update-behavior",
                                           buildStaticImmutableSchema_NoChildSchemaDefined(),
                                           item))

            .withMessageContaining("Converter not found for EnhancedType(software.amazon.awssdk.enhanced.dynamodb"
                                   + ".functionaltests.models.UpdateBehaviorTestModels$NestedImmutableChild)");
    }

    private <T> DynamoDbTable<T> createAndPut(String tableSuffix, TableSchema<T> schema, T item) {
        currentTestTableName = BASE_TABLE_NAME + tableSuffix + System.nanoTime();
        DynamoDbTable<T> table = enhancedClient.table(currentTestTableName, schema);
        table.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
        table.putItem(item);
        return table;
    }
}
