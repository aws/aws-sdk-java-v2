/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests.extensions;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.Order.FIRST;
import static software.amazon.awssdk.enhanced.dynamodb.mapper.Order.SECOND;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedUuid;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbVersionAttribute;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.LocalDynamoDbSyncTestBase;
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver;
import software.amazon.awssdk.enhanced.dynamodb.mapper.Order;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;

public class AutoGeneratedKeyExtensionTest extends LocalDynamoDbSyncTestBase {

    private static final TableSchema<BeanWithAutogeneratedKey> TABLE_SCHEMA =
        TableSchema.fromClass(BeanWithAutogeneratedKey.class);

    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(Stream.concat(
                                                    ExtensionResolver.defaultExtensions().stream(),
                                                    Stream.of(AutoGeneratedKeyExtension.create()))
                                                .collect(Collectors.toList()))
                              .build();

    private final DynamoDbTable<BeanWithAutogeneratedKey> mappedTable =
        enhancedClient.table(getConcreteTableName("autogenerated-key-table"), TABLE_SCHEMA);

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(r -> r.tableName(getConcreteTableName("autogenerated-key-table")));
    }

    @Test
    public void putItem_whenKeysNotPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();

        mappedTable.putItem(record);
        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void putItem_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey record = buildBeanWithAutogeneratedKeyAndKeysPopulated();

        mappedTable.putItem(record);
        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sortKey");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void updateItem_respectsUpdateBehavior() {
        // put initial item
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();
        mappedTable.putItem(record);
        BeanWithAutogeneratedKey afterPut = mappedTable.scan().items().stream().findFirst()
                                                       .orElseThrow(() -> new AssertionError("No record found"));
        String originalPk = afterPut.getId();
        String originalSk = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();
        String originalGsiSk = afterPut.getGsiSk();


        // update item
        BeanWithAutogeneratedKey update = new BeanWithAutogeneratedKey();
        update.setId(afterPut.getId());
        update.setSortKey(afterPut.getSortKey());

        mappedTable.updateItem(update);
        BeanWithAutogeneratedKey afterUpdate =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSortKey())));

        // id and sortKey preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
        assertThat(afterUpdate.getId()).isEqualTo(originalPk);
        assertThat(afterUpdate.getSortKey()).isEqualTo(originalSk);

        // gsiPk has WRITE_ALWAYS -> regenerates UUID on every update
        isValidUuid(afterUpdate.getGsiPk());
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk);

        // gsiSk has WRITE_IF_NOT_EXISTS -> preserves original UUID, only writes if null
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);
    }

    @Test
    public void batchWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey firstRecord = new BeanWithAutogeneratedKey();
        BeanWithAutogeneratedKey secondRecord = new BeanWithAutogeneratedKey();

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(BeanWithAutogeneratedKey.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));
        List<BeanWithAutogeneratedKey> results = mappedTable.scan().items().stream().collect(Collectors.toList());

        assertThat(results.size()).isEqualTo(2);
        isValidUuid(results.get(0).getId());
        isValidUuid(results.get(1).getId());
        isValidUuid(results.get(0).getSortKey());
        isValidUuid(results.get(1).getSortKey());
    }

    @Test
    public void batchWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey firstRecord = buildBeanWithAutogeneratedKeyAndKeysPopulated(1);
        BeanWithAutogeneratedKey secondRecord = buildBeanWithAutogeneratedKeyAndKeysPopulated(2);

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(BeanWithAutogeneratedKey.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));

        BeanWithAutogeneratedKey savedRecord1 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_1").sortValue("existing-sortKey_1")));
        assertThat(savedRecord1.getId()).isEqualTo("existing-id_1");
        assertThat(savedRecord1.getSortKey()).isEqualTo("existing-sortKey_1");
        assertThat(savedRecord1.getGsiPk()).isEqualTo("existing-gsiPk_1");
        assertThat(savedRecord1.getGsiSk()).isEqualTo("existing-gsiSk_1");

        BeanWithAutogeneratedKey savedRecord2 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_2").sortValue("existing-sortKey_2")));
        assertThat(savedRecord2.getId()).isEqualTo("existing-id_2");
        assertThat(savedRecord2.getSortKey()).isEqualTo("existing-sortKey_2");
        assertThat(savedRecord2.getGsiPk()).isEqualTo("existing-gsiPk_2");
        assertThat(savedRecord2.getGsiSk()).isEqualTo("existing-gsiSk_2");
    }

    @Test
    public void transactWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void transactWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey record = buildBeanWithAutogeneratedKeyAndKeysPopulated();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sortKey");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void putItem_onVersionedRecord_worksWithAutoGeneratedKey() {
        String tableName = "versioned-record-autogenerated-key-table";
        DynamoDbTable<BeanWithAutogeneratedKeyAndVersion> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithAutogeneratedKeyAndVersion.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithAutogeneratedKeyAndVersion record = new BeanWithAutogeneratedKeyAndVersion();
            record.setId("id");
            record.setData("data-v1");
            mappedTable.putItem(record);

            BeanWithAutogeneratedKeyAndVersion retrieved = mappedTable.scan().items().stream().findFirst()
                                                                      .orElseThrow(() -> new AssertionError("No record found"));
            isValidUuid(retrieved.getId());
            assertThat(retrieved.getData()).isEqualTo("data-v1");
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            retrieved.setData("data-v2");
            BeanWithAutogeneratedKeyAndVersion updated = mappedTable.updateItem(retrieved);
            isValidUuid(updated.getId());
            assertThat(updated.getData()).isEqualTo("data-v2");
            assertThat(updated.getVersion()).isEqualTo(2L);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationInConflictWithAutogeneratedUuidAnnotation_throwsException() {
        String tableName = "conflicting-annotations-record-autogenerated-key-table";
        DynamoDbTable<BeanWithConflictingAnnotations> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithConflictingAnnotations.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            assertThatThrownBy(() -> mappedTable.putItem(new BeanWithConflictingAnnotations()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                    + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationUsedOnNonKeyAttribute_throwsException() {
        String tableName = "annotation-on-non-key-attribute-record-autogenerated-key-table";
        DynamoDbTable<BeanWithAutogeneratedKeyOnNonKeyAttribute> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithAutogeneratedKeyOnNonKeyAttribute.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            assertThatThrownBy(() -> mappedTable.putItem(new BeanWithAutogeneratedKeyOnNonKeyAttribute()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "@DynamoDbAutoGeneratedKey can only be applied to key attributes: "
                    + "primary partition key, primary sort key, or GSI/LSI partition/sort keys. "
                    + "Invalid placement on attribute: nonKeyAttribute");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenNoAutogeneratedKeyAnnotationIsPresent_doesNotRegenerateUuids() {
        String tableName = "no-annotation-record-autogenerated-key-table";
        DynamoDbTable<BeanWithoutAutogeneratedKey> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithoutAutogeneratedKey.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithoutAutogeneratedKey record = new BeanWithoutAutogeneratedKey();
            record.setId("existing-id");
            record.setSortKey("existing-sortKey");
            record.setGsiPk("existing-gsiPk");
            record.setGsiSk("existing-gsiSk");
            record.setData("test");

            mappedTable.putItem(record);
            BeanWithoutAutogeneratedKey retrieved = mappedTable.getItem(
                r -> r.key(k -> k.partitionValue("existing-id").sortValue("existing-sortKey")));
            assertThat(retrieved.getId()).isEqualTo("existing-id");
            assertThat(retrieved.getSortKey()).isEqualTo("existing-sortKey");
            assertThat(retrieved.getGsiPk()).isEqualTo("existing-gsiPk");
            assertThat(retrieved.getGsiSk()).isEqualTo("existing-gsiSk");
            assertThat(retrieved.getData()).isEqualTo("test");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void createBean_givenAutogeneratedKeyAnnotationAppliedOnNonStringAttributeType_throwsException() {
        assertThatThrownBy(() -> TableSchema.fromBean(BeanWithAutogeneratedKeyOnAttributeWithInvalidType.class))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage(
                "Attribute 'id' of Class type class java.lang.Integer is not a suitable Java Class type to be used "
                + "as a Auto Generated Key attribute. Only String Class type is supported.");
    }


    // Tests with Mixed Composite Gsi
    @Test
    public void putItem_onBeanWithCompositeGsi_whenKeysNotPopulated_generatesNewUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();
            mappedTable.putItem(record);

            BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream()
                                                          .findFirst()
                                                          .orElseThrow(() -> new AssertionError("No record found"));

            isValidUuid(result.getId());
            isValidUuid(result.getSort());
            isValidUuid(result.getRootPartitionKey1());
            isValidUuid(result.getRootPartitionKey2());
            isValidUuid(result.getRootSortKey1());
            isValidUuid(result.getRootSortKey2());
            isValidUuid(result.getFlattenedKeys().flattenedPartitionKey1);
            isValidUuid(result.getFlattenedKeys().flattenedPartitionKey2);
            isValidUuid(result.getFlattenedKeys().flattenedSortKey1);
            isValidUuid(result.getFlattenedKeys().flattenedSortKey2);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_onBeanWithCompositeGsi_whenKeysAlreadyPopulated_preservesExistingUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
            BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated();
            mappedTable.putItem(record);

            BeanWithMixedCompositeGsi result =
                mappedTable.scan().items().stream()
                           .findFirst()
                           .orElseThrow(() -> new AssertionError("No record found"));


            assertThat(result.getId()).isEqualTo("existing-id");
            assertThat(result.getSort()).isEqualTo("existing-sort");
            assertThat(result.getRootPartitionKey1()).isEqualTo("existing-rootPk1");
            assertThat(result.getRootPartitionKey2()).isEqualTo("existing-rootPk2");
            assertThat(result.getRootSortKey1()).isEqualTo("existing-rootSk1");
            assertThat(result.getRootSortKey2()).isEqualTo("existing-rootSk2");
            assertThat(result.getFlattenedKeys().flattenedPartitionKey1).isEqualTo("existing-flattenedPk1");
            assertThat(result.getFlattenedKeys().flattenedPartitionKey2).isEqualTo("existing-flattenedPk2");
            assertThat(result.getFlattenedKeys().flattenedSortKey1).isEqualTo("existing-flattenedSk1");
            assertThat(result.getFlattenedKeys().flattenedSortKey2).isEqualTo("existing-flattenedSk2");

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void updateItem_onBeanWithCompositeKeys_respectsUpdateBehavior() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
            BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated();
            mappedTable.putItem(record);

            // put initial item
            BeanWithMixedCompositeGsi afterPut =
                mappedTable.scan().items().stream()
                           .findFirst()
                           .orElseThrow(() -> new AssertionError("No record found"));

            String originalPk = afterPut.getId();
            String originalSk = afterPut.getSort();
            String originalRootPartitionKey1 = afterPut.getRootPartitionKey1();
            String originalRootPartitionKey2 = afterPut.getRootPartitionKey2();
            String originalRootSortKey1 = afterPut.getRootSortKey1();
            String originalRootSortKey2 = afterPut.getRootSortKey2();
            String originalFlattenedPartitionKey1 = afterPut.getFlattenedKeys().flattenedPartitionKey1;
            String originalFlattenedPartitionKey2 = afterPut.getFlattenedKeys().flattenedPartitionKey2;
            String originalFlattenedSortKey1 = afterPut.getFlattenedKeys().flattenedSortKey1;
            String originalFlattenedSortKey2 = afterPut.getFlattenedKeys().flattenedSortKey2;

            // update item
            BeanWithMixedCompositeGsi update = new BeanWithMixedCompositeGsi();
            update.setId(afterPut.getId());
            update.setSort(afterPut.getSort());

            mappedTable.updateItem(update);
            BeanWithMixedCompositeGsi afterUpdate =
                mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSort())));


            // id and sort preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
            assertThat(afterUpdate.getId()).isEqualTo(originalPk);
            assertThat(afterUpdate.getSort()).isEqualTo(originalSk);

            // rootPartitionKey1, rootSortKey1, flattenedPartitionKey1, flattenedSortKey1 have WRITE_ALWAYS
            // ->  regenerates UUID on every update
            isValidUuid(afterUpdate.getRootPartitionKey1());
            isValidUuid(afterUpdate.getRootSortKey1());
            assertThat(afterUpdate.getRootPartitionKey1()).isNotEqualTo(originalRootPartitionKey1);
            assertThat(afterUpdate.getRootSortKey1()).isNotEqualTo(originalRootSortKey1);

            isValidUuid(afterUpdate.getFlattenedKeys().flattenedPartitionKey1);
            isValidUuid(afterUpdate.getFlattenedKeys().flattenedSortKey1);
            assertThat(afterUpdate.getFlattenedKeys().flattenedPartitionKey1).isNotEqualTo(originalFlattenedPartitionKey1);
            assertThat(afterUpdate.getFlattenedKeys().flattenedSortKey1).isNotEqualTo(originalFlattenedSortKey1);


            // rootPartitionKey2, rootSortKey2, flattenedPartitionKey2, flattenedSortKey2 have WRITE_IF_NOT_EXISTS
            // ->  preserves original UUID, only writes if null
            assertThat(afterUpdate.getRootPartitionKey2()).isEqualTo(originalRootPartitionKey2);
            assertThat(afterUpdate.getRootSortKey2()).isEqualTo(originalRootSortKey2);
            assertThat(afterUpdate.getFlattenedKeys().getFlattenedPartitionKey2()).isEqualTo(originalFlattenedPartitionKey2);
            assertThat(afterUpdate.getFlattenedKeys().getFlattenedSortKey2()).isEqualTo(originalFlattenedSortKey2);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void batchWrite_onBean_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
            BeanWithMixedCompositeGsi firstRecord = buildBeanWithCompositeGsiAndKeysPopulated(1);
            BeanWithMixedCompositeGsi secondRecord = buildBeanWithCompositeGsiAndKeysPopulated(2);

            enhancedClient.batchWriteItem(req -> req.addWriteBatch(
                WriteBatch.builder(BeanWithMixedCompositeGsi.class)
                          .mappedTableResource(mappedTable)
                          .addPutItem(firstRecord)
                          .addPutItem(secondRecord)
                          .build()));

            List<BeanWithMixedCompositeGsi> results = mappedTable.scan().items().stream().collect(Collectors.toList());

            assertThat(results.size()).isEqualTo(2);
            isValidUuid(results.get(0).getId());
            isValidUuid(results.get(1).getId());
            isValidUuid(results.get(0).getSort());
            isValidUuid(results.get(1).getSort());
            isValidUuid(results.get(0).getRootPartitionKey1());
            isValidUuid(results.get(1).getRootPartitionKey1());
            isValidUuid(results.get(0).getRootPartitionKey2());
            isValidUuid(results.get(1).getRootPartitionKey2());
            isValidUuid(results.get(0).getRootSortKey1());
            isValidUuid(results.get(1).getRootSortKey1());
            isValidUuid(results.get(0).getRootSortKey2());
            isValidUuid(results.get(1).getRootSortKey2());
            isValidUuid(results.get(0).getFlattenedKeys().flattenedPartitionKey1);
            isValidUuid(results.get(1).getFlattenedKeys().flattenedPartitionKey1);
            isValidUuid(results.get(0).getFlattenedKeys().flattenedPartitionKey2);
            isValidUuid(results.get(1).getFlattenedKeys().flattenedPartitionKey2);
            isValidUuid(results.get(0).getFlattenedKeys().flattenedSortKey1);
            isValidUuid(results.get(1).getFlattenedKeys().flattenedSortKey1);
            isValidUuid(results.get(0).getFlattenedKeys().flattenedSortKey2);
            isValidUuid(results.get(1).getFlattenedKeys().flattenedSortKey2);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void batchWrite_onBean_whenKeysAlreadyPopulated_preservesExistingUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
            BeanWithMixedCompositeGsi firstRecord = buildBeanWithCompositeGsiAndKeysPopulated(1);
            BeanWithMixedCompositeGsi secondRecord = buildBeanWithCompositeGsiAndKeysPopulated(2);

            enhancedClient.batchWriteItem(req -> req.addWriteBatch(WriteBatch.builder(BeanWithMixedCompositeGsi.class)
                                                                             .mappedTableResource(mappedTable)
                                                                             .addPutItem(firstRecord)
                                                                             .addPutItem(secondRecord)
                                                                             .build()));

            BeanWithMixedCompositeGsi firstSavedRecord =
                mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_1").sortValue("existing-sort_1")));
            assertThat(firstSavedRecord.getId()).isEqualTo("existing-id_1");
            assertThat(firstSavedRecord.getSort()).isEqualTo("existing-sort_1");
            assertThat(firstSavedRecord.getRootPartitionKey1()).isEqualTo("existing-rootPk1_1");
            assertThat(firstSavedRecord.getRootPartitionKey2()).isEqualTo("existing-rootPk2_1");
            assertThat(firstSavedRecord.getRootSortKey1()).isEqualTo("existing-rootSk1_1");
            assertThat(firstSavedRecord.getRootSortKey2()).isEqualTo("existing-rootSk2_1");
            assertThat(firstSavedRecord.getFlattenedKeys().flattenedPartitionKey1).isEqualTo("existing-flattenedPk1_1");
            assertThat(firstSavedRecord.getFlattenedKeys().flattenedPartitionKey2).isEqualTo("existing-flattenedPk2_1");
            assertThat(firstSavedRecord.getFlattenedKeys().flattenedSortKey1).isEqualTo("existing-flattenedSk1_1");
            assertThat(firstSavedRecord.getFlattenedKeys().flattenedSortKey2).isEqualTo("existing-flattenedSk2_1");


            BeanWithMixedCompositeGsi secondSavedRecord =
                mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_2").sortValue("existing-sort_2")));

            assertThat(secondSavedRecord.getId()).isEqualTo("existing-id_2");
            assertThat(secondSavedRecord.getSort()).isEqualTo("existing-sort_2");
            assertThat(secondSavedRecord.getRootPartitionKey1()).isEqualTo("existing-rootPk1_2");
            assertThat(secondSavedRecord.getRootPartitionKey2()).isEqualTo("existing-rootPk2_2");
            assertThat(secondSavedRecord.getRootSortKey1()).isEqualTo("existing-rootSk1_2");
            assertThat(secondSavedRecord.getRootSortKey2()).isEqualTo("existing-rootSk2_2");

            assertThat(secondSavedRecord.getFlattenedKeys().flattenedPartitionKey1).isEqualTo("existing-flattenedPk1_2");
            assertThat(secondSavedRecord.getFlattenedKeys().flattenedPartitionKey2).isEqualTo("existing-flattenedPk2_2");
            assertThat(secondSavedRecord.getFlattenedKeys().flattenedSortKey1).isEqualTo("existing-flattenedSk1_2");
            assertThat(secondSavedRecord.getFlattenedKeys().flattenedSortKey2).isEqualTo("existing-flattenedSk2_2");

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void transactWrite_onBean_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();
            enhancedClient.transactWriteItems(TransactWriteItemsEnhancedRequest.builder()
                                                                               .addPutItem(mappedTable, record)
                                                                               .build());

            BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream().findFirst()
                                                          .orElseThrow(() -> new AssertionError("No record found"));

            isValidUuid(result.getId());
            isValidUuid(result.getSort());
            isValidUuid(result.getRootPartitionKey1());
            isValidUuid(result.getRootPartitionKey2());
            isValidUuid(result.getRootSortKey1());
            isValidUuid(result.getRootSortKey2());
            isValidUuid(result.getFlattenedKeys().flattenedPartitionKey1);
            isValidUuid(result.getFlattenedKeys().flattenedPartitionKey2);
            isValidUuid(result.getFlattenedKeys().flattenedSortKey1);
            isValidUuid(result.getFlattenedKeys().flattenedSortKey2);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void transactWrite_onBean_whenKeysAlreadyPopulated_preservesExistingUuids() {
        String tableName = "mixed-gsi-autogenerated-key-table";
        DynamoDbTable<BeanWithMixedCompositeGsi> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithMixedCompositeGsi.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
            BeanWithMixedCompositeGsi record = buildBeanWithCompositeGsiAndKeysPopulated(1);
            enhancedClient.transactWriteItems(TransactWriteItemsEnhancedRequest.builder()
                                                                               .addPutItem(mappedTable, record)
                                                                               .build());

            BeanWithMixedCompositeGsi result = mappedTable.scan().items().stream().findFirst()
                                                          .orElseThrow(() -> new AssertionError("No record found"));

            assertThat(result.getId()).isEqualTo("existing-id_1");
            assertThat(result.getSort()).isEqualTo("existing-sort_1");
            assertThat(result.getRootPartitionKey1()).isEqualTo("existing-rootPk1_1");
            assertThat(result.getRootPartitionKey2()).isEqualTo("existing-rootPk2_1");
            assertThat(result.getRootSortKey1()).isEqualTo("existing-rootSk1_1");
            assertThat(result.getRootSortKey2()).isEqualTo("existing-rootSk2_1");
            assertThat(result.getFlattenedKeys().flattenedPartitionKey1).isEqualTo("existing-flattenedPk1_1");
            assertThat(result.getFlattenedKeys().flattenedPartitionKey2).isEqualTo("existing-flattenedPk2_1");
            assertThat(result.getFlattenedKeys().flattenedSortKey1).isEqualTo("existing-flattenedSk1_1");
            assertThat(result.getFlattenedKeys().flattenedSortKey2).isEqualTo("existing-flattenedSk2_1");

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }


    private static BeanWithAutogeneratedKey buildBeanWithAutogeneratedKeyAndKeysPopulated() {
        return buildBeanWithAutogeneratedKeyAndKeysPopulated(null);
    }

    private static BeanWithAutogeneratedKey buildBeanWithAutogeneratedKeyAndKeysPopulated(Integer index) {
        String suffix = index == null ? "" : "_" + index;

        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();
        record.setId("existing-id" + suffix);
        record.setSortKey("existing-sortKey" + suffix);
        record.setGsiPk("existing-gsiPk" + suffix);
        record.setGsiSk("existing-gsiSk" + suffix);

        return record;
    }

    private static BeanWithMixedCompositeGsi buildBeanWithCompositeGsiAndKeysPopulated() {
        return buildBeanWithCompositeGsiAndKeysPopulated(null);
    }

    private static BeanWithMixedCompositeGsi buildBeanWithCompositeGsiAndKeysPopulated(Integer index) {
        String suffix = index == null ? "" : "_" + index;

        BeanWithMixedCompositeGsi record = new BeanWithMixedCompositeGsi();
        record.setId("existing-id" + suffix);
        record.setSort("existing-sort" + suffix);
        record.setRootPartitionKey1("existing-rootPk1" + suffix);
        record.setRootPartitionKey2("existing-rootPk2" + suffix);
        record.setRootSortKey1("existing-rootSk1" + suffix);
        record.setRootSortKey2("existing-rootSk2" + suffix);

        BeanWithMixedCompositeGsi.FlattenedKeys flattenedKeys = new BeanWithMixedCompositeGsi.FlattenedKeys();
        flattenedKeys.setFlattenedPartitionKey1("existing-flattenedPk1" + suffix);
        flattenedKeys.setFlattenedPartitionKey2("existing-flattenedPk2" + suffix);
        flattenedKeys.setFlattenedSortKey1("existing-flattenedSk1" + suffix);
        flattenedKeys.setFlattenedSortKey2("existing-flattenedSk2" + suffix);
        record.setFlattenedKeys(flattenedKeys);

        return record;
    }


    @DynamoDbBean
    public static class BeanWithoutAutogeneratedKey {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;
        private String data;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKey {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyAndVersion {
        private String id;
        private Long version;
        private String data;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyOnAttributeWithInvalidType {
        private Integer id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public Integer getId() {
            return id;
        }

        public void setId(Integer id) {
            this.id = id;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyOnNonKeyAttribute {
        private String id;
        private String nonKeyAttribute;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbAutoGeneratedKey
        public String getNonKeyAttribute() {
            return nonKeyAttribute;
        }

        public void setNonKeyAttribute(String nonKeyAttribute) {
            this.nonKeyAttribute = nonKeyAttribute;
        }
    }

    @DynamoDbBean
    public static class BeanWithConflictingAnnotations {
        private String id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        @DynamoDbAutoGeneratedUuid
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }
    }

    @DynamoDbBean
    public static class BeanWithMixedCompositeGsi {
        private String id;
        private String sort;
        private String rootPartitionKey1;
        private String rootPartitionKey2;
        private String rootSortKey1;
        private String rootSortKey2;
        private FlattenedKeys flattenedKeys;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSort() {
            return sort;
        }

        public void setSort(String sort) {
            this.sort = sort;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi", "mixed_sort_gsi"}, order = FIRST)
        public String getRootPartitionKey1() {
            return rootPartitionKey1;
        }

        public void setRootPartitionKey1(String rootPartitionKey1) {
            this.rootPartitionKey1 = rootPartitionKey1;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi", "mixed_sort_gsi"}, order = SECOND)
        public String getRootPartitionKey2() {
            return rootPartitionKey2;
        }

        public void setRootPartitionKey2(String rootPartitionKey2) {
            this.rootPartitionKey2 = rootPartitionKey2;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = FIRST)
        public String getRootSortKey1() {
            return rootSortKey1;
        }

        public void setRootSortKey1(String rootSortKey1) {
            this.rootSortKey1 = rootSortKey1;
        }

        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = SECOND)
        public String getRootSortKey2() {
            return rootSortKey2;
        }

        public void setRootSortKey2(String rootSortKey2) {
            this.rootSortKey2 = rootSortKey2;
        }

        @DynamoDbFlatten
        public FlattenedKeys getFlattenedKeys() {
            return flattenedKeys;
        }

        public void setFlattenedKeys(FlattenedKeys flattenedKeys) {
            this.flattenedKeys = flattenedKeys;
        }

        @DynamoDbBean
        public static class FlattenedKeys {
            private String flattenedPartitionKey1;
            private String flattenedPartitionKey2;
            private String flattenedSortKey1;
            private String flattenedSortKey2;

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
            @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi"}, order = Order.THIRD)
            public String getFlattenedPartitionKey1() {
                return flattenedPartitionKey1;
            }

            public void setFlattenedPartitionKey1(String flattenedPartitionKey1) {
                this.flattenedPartitionKey1 = flattenedPartitionKey1;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
            @DynamoDbSecondaryPartitionKey(indexNames = {"mixed_partition_gsi", "full_mixed_gsi"}, order = Order.FOURTH)
            public String getFlattenedPartitionKey2() {
                return flattenedPartitionKey2;
            }

            public void setFlattenedPartitionKey2(String flattenedPartitionKey2) {
                this.flattenedPartitionKey2 = flattenedPartitionKey2;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
            @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = Order.THIRD)
            public String getFlattenedSortKey1() {
                return flattenedSortKey1;
            }

            public void setFlattenedSortKey1(String flattenedSortKey1) {
                this.flattenedSortKey1 = flattenedSortKey1;
            }

            @DynamoDbAutoGeneratedKey
            @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
            @DynamoDbSecondarySortKey(indexNames = {"mixed_sort_gsi", "full_mixed_gsi"}, order = Order.FOURTH)
            public String getFlattenedSortKey2() {
                return flattenedSortKey2;
            }

            public void setFlattenedSortKey2(String flattenedSortKey2) {
                this.flattenedSortKey2 = flattenedSortKey2;
            }
        }
    }
}


