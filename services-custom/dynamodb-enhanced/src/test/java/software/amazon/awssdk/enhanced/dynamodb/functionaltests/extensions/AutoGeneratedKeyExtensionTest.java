/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests.extensions;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedUuid;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbVersionAttribute;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.LocalDynamoDbSyncTestBase;
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;

public class AutoGeneratedKeyExtensionTest extends LocalDynamoDbSyncTestBase {

    private static final TableSchema<BeanWithAutogeneratedKey> TABLE_SCHEMA =
        TableSchema.fromClass(BeanWithAutogeneratedKey.class);

    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(Stream.concat(
                                                    ExtensionResolver.defaultExtensions().stream(),
                                                    Stream.of(AutoGeneratedKeyExtension.create()))
                                                .collect(Collectors.toList()))
                              .build();

    private final DynamoDbTable<BeanWithAutogeneratedKey> mappedTable =
        enhancedClient.table(getConcreteTableName("autogenerated-key-table"), TABLE_SCHEMA);

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(r -> r.tableName(getConcreteTableName("autogenerated-key-table")));
    }

    @Test
    public void putItem_whenKeysNotPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();

        mappedTable.putItem(record);
        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(isValidUuid(result.getId())).isTrue();
        assertThat(isValidUuid(result.getSortKey())).isTrue();
        assertThat(isValidUuid(result.getGsiPk())).isTrue();
        assertThat(isValidUuid(result.getGsiSk())).isTrue();
    }

    @Test
    public void putItem_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey record = buildBeanWithAutogeneratedKeyAndKeysPopulated();

        mappedTable.putItem(record);
        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sortKey");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void updateItem_respectsUpdateBehavior() {
        // put initial item
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();
        mappedTable.putItem(record);
        BeanWithAutogeneratedKey afterPut = mappedTable.scan().items().stream().findFirst()
                                                       .orElseThrow(() -> new AssertionError("No record found"));
        String originalPk = afterPut.getId();
        String originalSk = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();
        String originalGsiSk = afterPut.getGsiSk();


        // update item
        BeanWithAutogeneratedKey update = new BeanWithAutogeneratedKey();
        update.setId(afterPut.getId());
        update.setSortKey(afterPut.getSortKey());

        mappedTable.updateItem(update);
        BeanWithAutogeneratedKey afterUpdate =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSortKey())));

        // id and sortKey preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
        assertThat(afterUpdate.getId()).isEqualTo(originalPk);
        assertThat(afterUpdate.getSortKey()).isEqualTo(originalSk);

        // gsiPk has WRITE_ALWAYS -> regenerates UUID on every update
        assertThat(isValidUuid(afterUpdate.getGsiPk())).isTrue();
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk);

        // gsiSk has WRITE_IF_NOT_EXISTS -> preserves original UUID, only writes if null
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);
    }

    @Test
    public void batchWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey firstRecord = new BeanWithAutogeneratedKey();
        BeanWithAutogeneratedKey secondRecord = new BeanWithAutogeneratedKey();

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(BeanWithAutogeneratedKey.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));
        List<BeanWithAutogeneratedKey> results = mappedTable.scan().items().stream().collect(Collectors.toList());

        assertThat(results.size()).isEqualTo(2);
        assertThat(isValidUuid(results.get(0).getId())).isTrue();
        assertThat(isValidUuid(results.get(1).getId())).isTrue();
        assertThat(isValidUuid(results.get(0).getSortKey())).isTrue();
        assertThat(isValidUuid(results.get(1).getSortKey())).isTrue();
    }

    @Test
    public void batchWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey firstRecord = buildBeanWithAutogeneratedKeyAndKeysPopulated(1);
        BeanWithAutogeneratedKey secondRecord = buildBeanWithAutogeneratedKeyAndKeysPopulated(2);

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(BeanWithAutogeneratedKey.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));

        BeanWithAutogeneratedKey savedRecord1 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_1").sortValue("existing-sortKey_1")));
        assertThat(savedRecord1.getId()).isEqualTo("existing-id_1");
        assertThat(savedRecord1.getSortKey()).isEqualTo("existing-sortKey_1");
        assertThat(savedRecord1.getGsiPk()).isEqualTo("existing-gsiPk_1");
        assertThat(savedRecord1.getGsiSk()).isEqualTo("existing-gsiSk_1");

        BeanWithAutogeneratedKey savedRecord2 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id_2").sortValue("existing-sortKey_2")));
        assertThat(savedRecord2.getId()).isEqualTo("existing-id_2");
        assertThat(savedRecord2.getSortKey()).isEqualTo("existing-sortKey_2");
        assertThat(savedRecord2.getGsiPk()).isEqualTo("existing-gsiPk_2");
        assertThat(savedRecord2.getGsiSk()).isEqualTo("existing-gsiSk_2");
    }

    @Test
    public void transactWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(isValidUuid(result.getId())).isTrue();
        assertThat(isValidUuid(result.getSortKey())).isTrue();
        assertThat(isValidUuid(result.getGsiPk())).isTrue();
        assertThat(isValidUuid(result.getGsiSk())).isTrue();
    }

    @Test
    public void transactWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        BeanWithAutogeneratedKey record = buildBeanWithAutogeneratedKeyAndKeysPopulated();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        BeanWithAutogeneratedKey result = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sortKey");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void putItem_onVersionedRecord_andKeyNotPopulated_worksWithAutoGeneratedKeyAndGeneratesNewUuid() {
        String tableName = "versioned-record-autogenerated-key-table";
        DynamoDbTable<BeanWithAutogeneratedKeyAndVersion> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithAutogeneratedKeyAndVersion.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithAutogeneratedKeyAndVersion record = new BeanWithAutogeneratedKeyAndVersion();
            record.setData("data-v1");
            mappedTable.putItem(record); // id not set, should be auto generated

            BeanWithAutogeneratedKeyAndVersion retrieved =
                mappedTable.scan().items().stream().findFirst()
                           .orElseThrow(() -> new AssertionError("No record found"));

            String generatedUuid = retrieved.getId();
            assertThat(isValidUuid(generatedUuid)).isTrue();
            assertThat(retrieved.getData()).isEqualTo("data-v1");
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            retrieved.setData("data-v2");
            BeanWithAutogeneratedKeyAndVersion updated = mappedTable.updateItem(retrieved);
            assertThat(updated.getId()).isEqualTo(generatedUuid);
            assertThat(updated.getData()).isEqualTo("data-v2");
            assertThat(updated.getVersion()).isEqualTo(2L);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_onVersionedRecord_andAlreadyPopulatedKey_worksWithAutoGeneratedKeyAndPreservesInitialValue() {
        String tableName = "versioned-record-autogenerated-key-table";
        DynamoDbTable<BeanWithAutogeneratedKeyAndVersion> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithAutogeneratedKeyAndVersion.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithAutogeneratedKeyAndVersion record = new BeanWithAutogeneratedKeyAndVersion();
            record.setId("id");
            record.setData("data-v1");
            mappedTable.putItem(record);

            BeanWithAutogeneratedKeyAndVersion retrieved =
                mappedTable.scan().items().stream().findFirst()
                           .orElseThrow(() -> new AssertionError("No record found"));

            assertThat(retrieved.getId()).isEqualTo("id");
            assertThat(retrieved.getData()).isEqualTo("data-v1");
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            retrieved.setData("data-v2");
            BeanWithAutogeneratedKeyAndVersion updated = mappedTable.updateItem(retrieved);
            assertThat(updated.getId()).isEqualTo("id");
            assertThat(updated.getData()).isEqualTo("data-v2");
            assertThat(updated.getVersion()).isEqualTo(2L);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationInConflictWithAutogeneratedUuidAnnotation_throwsException() {
        String tableName = "conflicting-annotations-record-autogenerated-key-table";
        DynamoDbTable<BeanWithConflictingAnnotations> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithConflictingAnnotations.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            assertThatThrownBy(() -> mappedTable.putItem(new BeanWithConflictingAnnotations()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                    + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationUsedOnNonKeyAttribute_throwsException() {
        String tableName = "annotation-on-non-key-attribute-record-autogenerated-key-table";
        DynamoDbTable<BeanWithAutogeneratedKeyOnNonKeyAttribute> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithAutogeneratedKeyOnNonKeyAttribute.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithAutogeneratedKeyOnNonKeyAttribute bean = new BeanWithAutogeneratedKeyOnNonKeyAttribute();
            bean.setId("id");

            assertThatThrownBy(() -> mappedTable.putItem(bean))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "@DynamoDbAutoGeneratedKey can only be applied to key attributes: "
                    + "primary partition key, primary sort key, or GSI/LSI partition/sort keys. "
                    + "Invalid placement on attribute: nonKeyAttribute");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenNoAutogeneratedKeyAnnotationIsPresent_doesNotRegenerateUuids() {
        String tableName = "no-annotation-record-autogenerated-key-table";
        DynamoDbTable<BeanWithoutAutogeneratedKey> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(BeanWithoutAutogeneratedKey.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanWithoutAutogeneratedKey record = new BeanWithoutAutogeneratedKey();
            record.setId("existing-id");
            record.setSortKey("existing-sortKey");
            record.setGsiPk("existing-gsiPk");
            record.setGsiSk("existing-gsiSk");
            record.setData("test");

            mappedTable.putItem(record);
            BeanWithoutAutogeneratedKey retrieved = mappedTable.getItem(
                r -> r.key(k -> k.partitionValue("existing-id").sortValue("existing-sortKey")));
            assertThat(retrieved.getId()).isEqualTo("existing-id");
            assertThat(retrieved.getSortKey()).isEqualTo("existing-sortKey");
            assertThat(retrieved.getGsiPk()).isEqualTo("existing-gsiPk");
            assertThat(retrieved.getGsiSk()).isEqualTo("existing-gsiSk");
            assertThat(retrieved.getData()).isEqualTo("test");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void createBean_givenAutogeneratedKeyAnnotationAppliedOnNonStringAttributeType_throwsException() {
        assertThatThrownBy(() -> TableSchema.fromBean(BeanWithAutogeneratedKeyOnAttributeWithInvalidType.class))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage(
                "Attribute 'id' of Class type class java.lang.Integer is not a suitable Java Class type to be used "
                + "as a Auto Generated Key attribute. Only String Class type is supported.");
    }


    private static BeanWithAutogeneratedKey buildBeanWithAutogeneratedKeyAndKeysPopulated() {
        return buildBeanWithAutogeneratedKeyAndKeysPopulated(null);
    }

    private static BeanWithAutogeneratedKey buildBeanWithAutogeneratedKeyAndKeysPopulated(Integer index) {
        String suffix = index == null ? "" : "_" + index;

        BeanWithAutogeneratedKey record = new BeanWithAutogeneratedKey();
        record.setId("existing-id" + suffix);
        record.setSortKey("existing-sortKey" + suffix);
        record.setGsiPk("existing-gsiPk" + suffix);
        record.setGsiSk("existing-gsiSk" + suffix);

        return record;
    }


    @DynamoDbBean
    public static class BeanWithoutAutogeneratedKey {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;
        private String data;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKey {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyAndVersion {
        private String id;
        private Long version;
        private String data;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyOnAttributeWithInvalidType {
        private Integer id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public Integer getId() {
            return id;
        }

        public void setId(Integer id) {
            this.id = id;
        }
    }

    @DynamoDbBean
    public static class BeanWithAutogeneratedKeyOnNonKeyAttribute {
        private String id;
        private String nonKeyAttribute;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbAutoGeneratedKey
        public String getNonKeyAttribute() {
            return nonKeyAttribute;
        }

        public void setNonKeyAttribute(String nonKeyAttribute) {
            this.nonKeyAttribute = nonKeyAttribute;
        }
    }

    @DynamoDbBean
    public static class BeanWithConflictingAnnotations {
        private String id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        @DynamoDbAutoGeneratedUuid
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }
    }
}


