/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb.functionaltests.extensions;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedKey;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedUuid;
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbVersionAttribute;
import software.amazon.awssdk.enhanced.dynamodb.functionaltests.LocalDynamoDbSyncTestBase;
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver;
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondaryPartitionKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSecondarySortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey;
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;

public class AutoGeneratedKeyExtensionTest extends LocalDynamoDbSyncTestBase {

    private static final TableSchema<AutogeneratedKeyRecord> TABLE_SCHEMA =
        TableSchema.fromClass(AutogeneratedKeyRecord.class);

    private final DynamoDbEnhancedClient enhancedClient =
        DynamoDbEnhancedClient.builder()
                              .dynamoDbClient(getDynamoDbClient())
                              .extensions(Stream.concat(
                                                    ExtensionResolver.defaultExtensions().stream(),
                                                    Stream.of(AutoGeneratedKeyExtension.create()))
                                                .collect(Collectors.toList()))
                              .build();

    private final DynamoDbTable<AutogeneratedKeyRecord> mappedTable =
        enhancedClient.table(getConcreteTableName("autogenerated-key-table"), TABLE_SCHEMA);

    @Before
    public void createTable() {
        mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));
    }

    @After
    public void deleteTable() {
        getDynamoDbClient().deleteTable(r -> r.tableName(getConcreteTableName("autogenerated-key-table")));
    }

    @Test
    public void putItem_whenKeysNotPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();

        mappedTable.putItem(record);
        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void putItem_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        record.setId("existing-id");
        record.setSortKey("existing-sk");
        record.setGsiPk("existing-gsiPk");
        record.setGsiSk("existing-gsiSk");

        mappedTable.putItem(record);
        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sk");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void updateItem_respectsUpdateBehavior() {
        // put initial item
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        mappedTable.putItem(record);
        AutogeneratedKeyRecord afterPut = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));
        String originalPk = afterPut.getId();
        String originalSk = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();
        String originalGsiSk = afterPut.getGsiSk();


        // update item
        AutogeneratedKeyRecord update = new AutogeneratedKeyRecord();
        update.setId(afterPut.getId());
        update.setSortKey(afterPut.getSortKey());

        mappedTable.updateItem(update);
        AutogeneratedKeyRecord afterUpdate =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSortKey())));

        // id and sortKey preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
        assertThat(afterUpdate.getId()).isEqualTo(originalPk);
        assertThat(afterUpdate.getSortKey()).isEqualTo(originalSk);

        // gsiPk has WRITE_ALWAYS: regenerates UUID on every update
        isValidUuid(afterUpdate.getGsiPk());
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk);

        // gsiSk has WRITE_IF_NOT_EXISTS: preserves original UUID, only writes if null
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);
    }

    @Test
    public void batchWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord firstRecord = new AutogeneratedKeyRecord();
        AutogeneratedKeyRecord secondRecord = new AutogeneratedKeyRecord();

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(AutogeneratedKeyRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));
        List<AutogeneratedKeyRecord> results = mappedTable.scan().items().stream().collect(Collectors.toList());

        assertThat(results.size()).isEqualTo(2);
        isValidUuid(results.get(0).getId());
        isValidUuid(results.get(1).getId());
        isValidUuid(results.get(0).getSortKey());
        isValidUuid(results.get(1).getSortKey());
    }

    @Test
    public void batchWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord firstRecord = new AutogeneratedKeyRecord();
        firstRecord.setId("existing-id-1");
        firstRecord.setSortKey("existing-sk-1");
        firstRecord.setGsiPk("existing-gsiPk-1");
        firstRecord.setGsiSk("existing-gsiSk-1");

        AutogeneratedKeyRecord secondRecord = new AutogeneratedKeyRecord();
        secondRecord.setId("existing-id-2");
        secondRecord.setSortKey("existing-sk-2");
        secondRecord.setGsiPk("existing-gsiPk-2");
        secondRecord.setGsiSk("existing-gsiSk-2");

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(AutogeneratedKeyRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(firstRecord)
                      .addPutItem(secondRecord)
                      .build()));

        AutogeneratedKeyRecord savedRecord1 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id-1").sortValue("existing-sk-1")));
        assertThat(savedRecord1.getId()).isEqualTo("existing-id-1");
        assertThat(savedRecord1.getSortKey()).isEqualTo("existing-sk-1");
        assertThat(savedRecord1.getGsiPk()).isEqualTo("existing-gsiPk-1");
        assertThat(savedRecord1.getGsiSk()).isEqualTo("existing-gsiSk-1");

        AutogeneratedKeyRecord savedRecord2 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id-2").sortValue("existing-sk-2")));
        assertThat(savedRecord2.getId()).isEqualTo("existing-id-2");
        assertThat(savedRecord2.getSortKey()).isEqualTo("existing-sk-2");
        assertThat(savedRecord2.getGsiPk()).isEqualTo("existing-gsiPk-2");
        assertThat(savedRecord2.getGsiSk()).isEqualTo("existing-gsiSk-2");
    }

    @Test
    public void transactWrite_whenKeysNotAlreadyPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void transactWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        record.setId("existing-id-1");
        record.setSortKey("existing-sk-1");
        record.setGsiPk("existing-gsiPk-1");
        record.setGsiSk("existing-gsiSk-1");

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id-1");
        assertThat(result.getSortKey()).isEqualTo("existing-sk-1");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk-1");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk-1");
    }

    @Test
    public void putItem_onVersionedRecord_worksWithAutoGeneratedKey() {
        String tableName = "versioned-record-autogenerated-key-table";
        DynamoDbTable<AutogeneratedKeyVersionedRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyVersionedRecord.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            AutogeneratedKeyVersionedRecord record = new AutogeneratedKeyVersionedRecord();
            record.setId("id");
            record.setData("data-v1");
            mappedTable.putItem(record);

            AutogeneratedKeyVersionedRecord retrieved = mappedTable.scan().items().stream().findFirst()
                                                                   .orElseThrow(() -> new AssertionError("No record found"));
            isValidUuid(retrieved.getId());
            assertThat(retrieved.getData()).isEqualTo("data-v1");
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            retrieved.setData("data-v2");
            AutogeneratedKeyVersionedRecord updated = mappedTable.updateItem(retrieved);
            isValidUuid(updated.getId());
            assertThat(updated.getData()).isEqualTo("data-v2");
            assertThat(updated.getVersion()).isEqualTo(2L);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationInConflictWithAutogeneratedUuidAnnotation_throwsException() {
        String tableName = "conflicting-annotations-record-autogenerated-key-table";
        DynamoDbTable<AutogeneratedKeyConflictingRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyConflictingRecord.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            assertThatThrownBy(() -> mappedTable.putItem(new AutogeneratedKeyConflictingRecord()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "Attribute 'id' cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid annotations. "
                    + "These annotations have conflicting behaviors and cannot be used together on the same attribute.");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationUsedOnNonKeyAttribute_throwsException() {
        String tableName = "annotation-on-non-key-attribute-record-autogenerated-key-table";
        DynamoDbTable<AutogeneratedKeyOnNonKeyAttributeRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyOnNonKeyAttributeRecord.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            assertThatThrownBy(() -> mappedTable.putItem(new AutogeneratedKeyOnNonKeyAttributeRecord()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage(
                    "@DynamoDbAutoGeneratedKey can only be applied to key attributes: "
                    + "primary partition key, primary sort key, or GSI/LSI partition/sort keys. "
                    + "Invalid placement on attribute: nonKeyAttribute");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenNoAutogeneratedKeyAnnotationIsPresent_doesNotRegenerateUuids() {
        String tableName = "no-annotation-record-autogenerated-key-table";
        DynamoDbTable<BeanRecord> mappedTable = enhancedClient.table(tableName, TableSchema.fromClass(BeanRecord.class));

        try {
            mappedTable.createTable(r -> r.provisionedThroughput(getDefaultProvisionedThroughput()));

            BeanRecord record = new BeanRecord();
            record.setId("existing-id");
            record.setSortKey("existing-sk");
            record.setGsiPk("existing-gsiPk");
            record.setGsiSk("existing-gsiSk");
            record.setData("test");

            mappedTable.putItem(record);
            BeanRecord retrieved = mappedTable.getItem(
                r -> r.key(k -> k.partitionValue("existing-id").sortValue("existing-sk")));
            assertThat(retrieved.getId()).isEqualTo("existing-id");
            assertThat(retrieved.getSortKey()).isEqualTo("existing-sk");
            assertThat(retrieved.getGsiPk()).isEqualTo("existing-gsiPk");
            assertThat(retrieved.getGsiSk()).isEqualTo("existing-gsiSk");
            assertThat(retrieved.getData()).isEqualTo("test");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void createBean_givenAutogeneratedKeyAnnotationAppliedOnNonStringAttributeType_throwsException() {
        assertThatThrownBy(() -> TableSchema.fromBean(AutogeneratedKeyInvalidTypeRecord.class))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage(
                "Attribute 'id' of Class type class java.lang.Integer is not a suitable Java Class type to be used "
                + "as a Auto Generated Key attribute. Only String Class type is supported.");
    }

    @DynamoDbBean
    public static class BeanRecord {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;
        private String data;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class AutogeneratedKeyRecord {
        private String id;
        private String sortKey;
        private String gsiPk;
        private String gsiSk;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbSortKey
        @DynamoDbAutoGeneratedKey
        public String getSortKey() {
            return sortKey;
        }

        public void setSortKey(String sortKey) {
            this.sortKey = sortKey;
        }

        @DynamoDbSecondaryPartitionKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        public String getGsiPk() {
            return gsiPk;
        }

        public void setGsiPk(String gsiPk) {
            this.gsiPk = gsiPk;
        }

        @DynamoDbSecondarySortKey(indexNames = "gsi1")
        @DynamoDbAutoGeneratedKey
        @DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        public String getGsiSk() {
            return gsiSk;
        }

        public void setGsiSk(String gsiSk) {
            this.gsiSk = gsiSk;
        }
    }

    @DynamoDbBean
    public static class AutogeneratedKeyVersionedRecord {
        private String id;
        private Long version;
        private String data;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        public String getData() {
            return data;
        }

        public void setData(String data) {
            this.data = data;
        }
    }

    @DynamoDbBean
    public static class AutogeneratedKeyInvalidTypeRecord {
        private Integer id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        public Integer getId() {
            return id;
        }

        public void setId(Integer id) {
            this.id = id;
        }
    }

    @DynamoDbBean
    public static class AutogeneratedKeyOnNonKeyAttributeRecord {
        private String id;
        private String nonKeyAttribute;

        @DynamoDbPartitionKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDbAutoGeneratedKey
        public String getNonKeyAttribute() {
            return nonKeyAttribute;
        }

        public void setNonKeyAttribute(String nonKeyAttribute) {
            this.nonKeyAttribute = nonKeyAttribute;
        }
    }

    @DynamoDbBean
    public static class AutogeneratedKeyConflictingRecord {
        private String id;

        @DynamoDbPartitionKey
        @DynamoDbAutoGeneratedKey
        @DynamoDbAutoGeneratedUuid
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }
    }
}


