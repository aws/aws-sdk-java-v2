/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.awssdk.enhanced.dynamodb;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static software.amazon.awssdk.enhanced.dynamodb.UuidTestUtils.isValidUuid;

import java.util.List;
import java.util.stream.Collectors;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedKeyExtension;
import software.amazon.awssdk.enhanced.dynamodb.extensions.VersionedRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.BeanRecord;
import software.amazon.awssdk.enhanced.dynamodb.model.TransactWriteItemsEnhancedRequest;
import software.amazon.awssdk.enhanced.dynamodb.model.WriteBatch;
import software.amazon.awssdk.enhanced.dynamodb.model.autogeneratedkeys.AutogeneratedKeyConflictingRecord;
import software.amazon.awssdk.enhanced.dynamodb.model.autogeneratedkeys.AutogeneratedKeyInvalidTypeRecord;
import software.amazon.awssdk.enhanced.dynamodb.model.autogeneratedkeys.AutogeneratedKeyOnNonKeyAttributeRecord;
import software.amazon.awssdk.enhanced.dynamodb.model.autogeneratedkeys.AutogeneratedKeyRecord;
import software.amazon.awssdk.enhanced.dynamodb.model.autogeneratedkeys.AutogeneratedKeyVersionedRecord;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;

public class AutoGeneratedKeyIntegrationTest extends DynamoDbEnhancedIntegrationTestBase {

    private static final String TABLE_NAME = createTestTableName();

    private static DynamoDbClient dynamoDbClient;
    private static DynamoDbEnhancedClient enhancedClient;
    private static DynamoDbTable<AutogeneratedKeyRecord> mappedTable;

    @BeforeClass
    public static void beforeClass() {
        dynamoDbClient = createDynamoDbClient();
        enhancedClient = DynamoDbEnhancedClient.builder()
                                               .dynamoDbClient(dynamoDbClient)
                                               .extensions(AutoGeneratedKeyExtension.builder().build())
                                               .build();
        mappedTable = enhancedClient.table(TABLE_NAME, TableSchema.fromClass(AutogeneratedKeyRecord.class));
        mappedTable.createTable();
        dynamoDbClient.waiter().waitUntilTableExists(r -> r.tableName(TABLE_NAME));
    }

    @After
    public void tearDown() {
        mappedTable.scan()
                   .items()
                   .forEach(record -> mappedTable.deleteItem(record));
    }

    @AfterClass
    public static void afterClass() {
        try {
            dynamoDbClient.deleteTable(r -> r.tableName(TABLE_NAME));
        } finally {
            dynamoDbClient.close();
        }
    }

    @Test
    public void putItem_whenKeysNotPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();

        mappedTable.putItem(record);
        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));
        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void putItem_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        record.setId("existing-id");
        record.setSortKey("existing-sk");
        record.setGsiPk("existing-gsiPk");
        record.setGsiSk("existing-gsiSk");

        mappedTable.putItem(record);
        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id");
        assertThat(result.getSortKey()).isEqualTo("existing-sk");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk");
    }

    @Test
    public void updateItem_respectsUpdateBehavior() {
        // put initial item
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        mappedTable.putItem(record);
        AutogeneratedKeyRecord afterPut = mappedTable.scan().items().stream().findFirst()
                                                     .orElseThrow(() -> new AssertionError("No record found"));
        String originalPk = afterPut.getId();
        String originalSk = afterPut.getSortKey();
        String originalGsiPk = afterPut.getGsiPk();
        String originalGsiSk = afterPut.getGsiSk();


        // update item
        AutogeneratedKeyRecord update = new AutogeneratedKeyRecord();
        update.setId(afterPut.getId());
        update.setSortKey(afterPut.getSortKey());

        mappedTable.updateItem(update);
        AutogeneratedKeyRecord afterUpdate =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue(afterPut.getId()).sortValue(afterPut.getSortKey())));

        // id and sortKey preserve original values as DynamoDbUpdateBehavior has no effect on primary partition keys or sort keys
        assertThat(afterUpdate.getId()).isEqualTo(originalPk);
        assertThat(afterUpdate.getSortKey()).isEqualTo(originalSk);

        // gsiPk has WRITE_ALWAYS: regenerates UUID on every update
        isValidUuid(afterUpdate.getGsiPk());
        assertThat(afterUpdate.getGsiPk()).isNotEqualTo(originalGsiPk);

        // gsiSk has WRITE_IF_NOT_EXISTS: preserves original UUID, only writes if null
        assertThat(afterUpdate.getGsiSk()).isEqualTo(originalGsiSk);
    }

    @Test
    public void batchWrite_whenKeysNotPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord record1 = new AutogeneratedKeyRecord();
        AutogeneratedKeyRecord record2 = new AutogeneratedKeyRecord();

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(AutogeneratedKeyRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(record1)
                      .addPutItem(record2)
                      .build()));
        List<AutogeneratedKeyRecord> results = mappedTable.scan().items().stream().collect(Collectors.toList());

        assertThat(results.size()).isEqualTo(2);
        isValidUuid(results.get(0).getId());
        isValidUuid(results.get(1).getId());
        isValidUuid(results.get(0).getSortKey());
        isValidUuid(results.get(1).getSortKey());
    }

    @Test
    public void batchWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord record1 = new AutogeneratedKeyRecord();
        record1.setId("existing-id-1");
        record1.setSortKey("existing-sk-1");
        record1.setGsiPk("existing-gsiPk-1");
        record1.setGsiSk("existing-gsiSk-1");

        AutogeneratedKeyRecord record2 = new AutogeneratedKeyRecord();
        record2.setId("existing-id-2");
        record2.setSortKey("existing-sk-2");
        record2.setGsiPk("existing-gsiPk-2");
        record2.setGsiSk("existing-gsiSk-2");

        enhancedClient.batchWriteItem(req -> req.addWriteBatch(
            WriteBatch.builder(AutogeneratedKeyRecord.class)
                      .mappedTableResource(mappedTable)
                      .addPutItem(record1)
                      .addPutItem(record2)
                      .build()));

        AutogeneratedKeyRecord savedRecord1 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id-1").sortValue("existing-sk-1")));
        assertThat(savedRecord1.getId()).isEqualTo("existing-id-1");
        assertThat(savedRecord1.getSortKey()).isEqualTo("existing-sk-1");
        assertThat(savedRecord1.getGsiPk()).isEqualTo("existing-gsiPk-1");
        assertThat(savedRecord1.getGsiSk()).isEqualTo("existing-gsiSk-1");

        AutogeneratedKeyRecord savedRecord2 =
            mappedTable.getItem(r -> r.key(k -> k.partitionValue("existing-id-2").sortValue("existing-sk-2")));
        assertThat(savedRecord2.getId()).isEqualTo("existing-id-2");
        assertThat(savedRecord2.getSortKey()).isEqualTo("existing-sk-2");
        assertThat(savedRecord2.getGsiPk()).isEqualTo("existing-gsiPk-2");
        assertThat(savedRecord2.getGsiSk()).isEqualTo("existing-gsiSk-2");
    }

    @Test
    public void transactWrite_whenKeysNotPopulated_generatesNewUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        isValidUuid(result.getId());
        isValidUuid(result.getSortKey());
        isValidUuid(result.getGsiPk());
        isValidUuid(result.getGsiSk());
    }

    @Test
    public void transactWrite_whenKeysAlreadyPopulated_preservesExistingUuids() {
        AutogeneratedKeyRecord record = new AutogeneratedKeyRecord();
        record.setId("existing-id-1");
        record.setSortKey("existing-sk-1");
        record.setGsiPk("existing-gsiPk-1");
        record.setGsiSk("existing-gsiSk-1");

        enhancedClient.transactWriteItems(
            TransactWriteItemsEnhancedRequest.builder()
                                             .addPutItem(mappedTable, record)
                                             .build());

        AutogeneratedKeyRecord result = mappedTable.scan().items().stream().findFirst()
                                                   .orElseThrow(() -> new AssertionError("No record found"));

        assertThat(result.getId()).isEqualTo("existing-id-1");
        assertThat(result.getSortKey()).isEqualTo("existing-sk-1");
        assertThat(result.getGsiPk()).isEqualTo("existing-gsiPk-1");
        assertThat(result.getGsiSk()).isEqualTo("existing-gsiSk-1");
    }

    @Test
    public void putItem_onVersionedRecord_worksWithAutoGeneratedKey() {
        String tableName = createTestTableName();

        DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder()
                                                                      .dynamoDbClient(dynamoDbClient)
                                                                      .extensions(AutoGeneratedKeyExtension.builder().build(),
                                                                                  VersionedRecordExtension.builder().build())
                                                                      .build();
        DynamoDbTable<AutogeneratedKeyVersionedRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyVersionedRecord.class));

        try {
            mappedTable.createTable();
            dynamoDbClient.waiter().waitUntilTableExists(r -> r.tableName(tableName));

            AutogeneratedKeyVersionedRecord record = new AutogeneratedKeyVersionedRecord();
            record.setData("data-v1");
            mappedTable.putItem(record);

            AutogeneratedKeyVersionedRecord retrieved =
                mappedTable.scan().items().stream().findFirst()
                           .orElseThrow(() -> new AssertionError("No record found"));
            isValidUuid(retrieved.getId());
            assertThat(retrieved.getData()).isEqualTo("data-v1");
            assertThat(retrieved.getVersion()).isEqualTo(1L);

            retrieved.setData("data-v2");
            AutogeneratedKeyVersionedRecord updated = mappedTable.updateItem(retrieved);
            isValidUuid(updated.getId());
            assertThat(updated.getData()).isEqualTo("data-v2");
            assertThat(updated.getVersion()).isEqualTo(2L);

        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationInConflictWithAutogeneratedUuidAnnotation_throwsException() {
        String tableName = createTestTableName();
        DynamoDbTable<AutogeneratedKeyConflictingRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyConflictingRecord.class));

        try {
            mappedTable.createTable();
            dynamoDbClient.waiter().waitUntilTableExists(r -> r.tableName(tableName));

            assertThatThrownBy(() -> mappedTable.putItem(new AutogeneratedKeyConflictingRecord()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("cannot have both @DynamoDbAutoGeneratedKey and @DynamoDbAutoGeneratedUuid");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenAnnotationUsedOnNonKeyAttribute_throwsException() {
        String tableName = createTestTableName();
        DynamoDbTable<AutogeneratedKeyOnNonKeyAttributeRecord> mappedTable =
            enhancedClient.table(tableName, TableSchema.fromClass(AutogeneratedKeyOnNonKeyAttributeRecord.class));

        try {
            mappedTable.createTable();
            dynamoDbClient.waiter().waitUntilTableExists(r -> r.tableName(tableName));

            assertThatThrownBy(() -> mappedTable.putItem(new AutogeneratedKeyOnNonKeyAttributeRecord()))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("@DynamoDbAutoGeneratedKey can only be applied to key attributes");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void putItem_whenNoAutogeneratedKeyAnnotationIsPresent_doesNotRegenerateUuids() {
        String tableName = createTestTableName();
        DynamoDbTable<BeanRecord> mappedTable = enhancedClient.table(tableName, TableSchema.fromClass(BeanRecord.class));

        try {
            mappedTable.createTable();
            dynamoDbClient.waiter().waitUntilTableExists(r -> r.tableName(tableName));

            BeanRecord record = new BeanRecord();
            record.setId("existing-id");
            record.setSortKey("existing-sk");
            record.setGsiPk("existing-gsiPk");
            record.setGsiSk("existing-gsiSk");
            record.setData("test");

            mappedTable.putItem(record);
            BeanRecord retrieved = mappedTable.getItem(
                r -> r.key(k -> k.partitionValue("existing-id").sortValue("existing-sk")));
            assertThat(retrieved.getId()).isEqualTo("existing-id");
            assertThat(retrieved.getSortKey()).isEqualTo("existing-sk");
            assertThat(retrieved.getGsiPk()).isEqualTo("existing-gsiPk");
            assertThat(retrieved.getGsiSk()).isEqualTo("existing-gsiSk");
            assertThat(retrieved.getData()).isEqualTo("test");
        } finally {
            try {
                mappedTable.deleteTable();
            } catch (Exception ignored) {
            }
        }
    }

    @Test
    public void createBean_givenAutogeneratedKeyAnnotationAppliedOnNonStringAttributeType_throwsException() {
        assertThatThrownBy(() -> TableSchema.fromBean(AutogeneratedKeyInvalidTypeRecord.class))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("not a suitable Java Class type to be used as a Auto Generated Key attribute")
            .hasMessageContaining("Only String Class type is supported");
    }
}
