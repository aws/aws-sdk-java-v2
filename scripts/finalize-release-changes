#!/usr/bin/env python

from __future__ import print_function
from datetime import date
import re
import shutil
import os
import argparse
from changelog.model import Version
from changelog.util import load_unreleased_changes, marshall_release_changes, parse_version_string

VERSION_REGEX = re.compile('^[0-9]+\.[0-9]+\.[0-9]+?(-.+)$')
DATE_REGEX = re.compile('^[0-9]{4}-[0-9]{2}-[0-9]{2}$')

def validate_args(args):
    if not VERSION_REGEX.match(args.release_version):
        print("--release-version is not in the correct format.")
    if not DATE_REGEX.match(args.release_date):
        print("--release-date is not in the correct format.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Finalize the unrelease changes in .changes/next-release")
    parser.add_argument('--release-version', dest='release_version', required=True, help="The version that the changes desrcribe. Must be in the form MAJOR.MINOR.PATCH")
    parser.add_argument('--release-date', dest='release_date', default=date.today().isoformat(), help="The date for the release, in ISO 8601 format (YYYY-MM-DD). Defaults to the current date.")
    args = parser.parse_args()

    validate_args(args)

    next_release = load_unreleased_changes('.changes/next-release')
    if next_release is None:
        print("There are no unreleased changes.")
        exit(0)

    next_release.version = parse_version_string(args.release_version)
    next_release.date = args.release_date

    next_release_json = marshall_release_changes(next_release)

    filename = ".changes/%s.json" % next_release.version

    if os.path.isfile(filename):
        print("The file %s already exists!" % filename)
        exit(1)

    with open(filename, 'w') as f:
        f.write(next_release_json)

    shutil.rmtree('.changes/next-release')
